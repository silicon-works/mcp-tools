#!/usr/bin/env python3
"""
OpenSploit MCP Server: exploit-runner

Execute CVE exploits and PoCs from searchsploit, GitHub, or custom scripts.
Provides sandboxed execution with output capture.
"""

import asyncio
import base64
import json
import os
import re
import shutil
import subprocess
import tempfile
from pathlib import Path
from typing import Any, Dict, List, Optional

from mcp_common import BaseMCPServer, ToolResult, ToolError

# Workspace for exploit files
EXPLOIT_DIR = Path("/tmp/exploits")


class ExploitRunnerServer(BaseMCPServer):
    """MCP server for running exploits."""

    def __init__(self):
        super().__init__(
            name="exploit-runner",
            description="Execute CVE exploits and PoCs safely",
            version="1.0.0",
        )

        # Ensure exploit directory exists
        EXPLOIT_DIR.mkdir(parents=True, exist_ok=True)

        self.register_method(
            name="run_python",
            description="Execute a Python exploit script",
            params={
                "script": {
                    "type": "string",
                    "required": True,
                    "description": "Python script content or path",
                },
                "args": {
                    "type": "array",
                    "description": "Command line arguments for the script",
                },
                "is_path": {
                    "type": "boolean",
                    "default": False,
                    "description": "Whether script is a file path (vs content)",
                },
                "is_base64": {
                    "type": "boolean",
                    "default": False,
                    "description": "Whether script content is base64 encoded",
                },
                "python_version": {
                    "type": "enum",
                    "values": ["python3", "python2"],
                    "default": "python3",
                    "description": "Python version to use",
                },
                "timeout": {
                    "type": "integer",
                    "default": 120,
                    "description": "Execution timeout in seconds",
                },
                "env": {
                    "type": "object",
                    "description": "Environment variables to set",
                },
            },
            handler=self.run_python,
        )

        self.register_method(
            name="run_shell",
            description="Execute a shell script or command",
            params={
                "script": {
                    "type": "string",
                    "required": True,
                    "description": "Shell script content or command",
                },
                "args": {
                    "type": "array",
                    "description": "Command line arguments",
                },
                "shell": {
                    "type": "enum",
                    "values": ["bash", "sh", "zsh"],
                    "default": "bash",
                    "description": "Shell to use",
                },
                "timeout": {
                    "type": "integer",
                    "default": 120,
                    "description": "Execution timeout",
                },
                "env": {
                    "type": "object",
                    "description": "Environment variables",
                },
            },
            handler=self.run_shell,
        )

        self.register_method(
            name="run_ruby",
            description="Execute a Ruby exploit script",
            params={
                "script": {
                    "type": "string",
                    "required": True,
                    "description": "Ruby script content or path",
                },
                "args": {
                    "type": "array",
                    "description": "Command line arguments",
                },
                "is_path": {
                    "type": "boolean",
                    "default": False,
                    "description": "Whether script is a file path",
                },
                "timeout": {
                    "type": "integer",
                    "default": 120,
                    "description": "Execution timeout",
                },
            },
            handler=self.run_ruby,
        )

        self.register_method(
            name="prepare_exploit",
            description="Prepare exploit by downloading and setting up dependencies",
            params={
                "content": {
                    "type": "string",
                    "required": True,
                    "description": "Exploit script content (or base64)",
                },
                "filename": {
                    "type": "string",
                    "required": True,
                    "description": "Filename to save as",
                },
                "is_base64": {
                    "type": "boolean",
                    "default": False,
                    "description": "Whether content is base64 encoded",
                },
                "requirements": {
                    "type": "array",
                    "description": "Python packages to install",
                },
            },
            handler=self.prepare_exploit,
        )

        self.register_method(
            name="list_exploits",
            description="List prepared exploits in workspace",
            params={},
            handler=self.list_exploits,
        )

        self.register_method(
            name="analyze_exploit",
            description="Analyze an exploit script for safety and requirements",
            params={
                "script": {
                    "type": "string",
                    "required": True,
                    "description": "Exploit script content",
                },
                "language": {
                    "type": "enum",
                    "values": ["python", "ruby", "shell", "auto"],
                    "default": "auto",
                    "description": "Script language",
                },
            },
            handler=self.analyze_exploit,
        )

    async def _run_process(
        self,
        cmd: List[str],
        timeout: int = 120,
        env: Optional[Dict[str, str]] = None,
        cwd: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Run a subprocess with timeout."""
        process_env = os.environ.copy()
        if env:
            process_env.update(env)

        try:
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                env=process_env,
                cwd=cwd,
            )

            stdout, stderr = await asyncio.wait_for(
                proc.communicate(),
                timeout=timeout,
            )

            return {
                "returncode": proc.returncode,
                "stdout": stdout.decode('utf-8', errors='replace'),
                "stderr": stderr.decode('utf-8', errors='replace'),
                "success": proc.returncode == 0,
            }

        except asyncio.TimeoutError:
            proc.kill()
            return {
                "returncode": -1,
                "stdout": "",
                "stderr": f"Process timed out after {timeout} seconds",
                "success": False,
                "timeout": True,
            }
        except Exception as e:
            return {
                "returncode": -1,
                "stdout": "",
                "stderr": str(e),
                "success": False,
                "error": str(e),
            }

    async def run_python(
        self,
        script: str,
        args: Optional[List[str]] = None,
        is_path: bool = False,
        is_base64: bool = False,
        python_version: str = "python3",
        timeout: int = 120,
        env: Optional[Dict[str, str]] = None,
    ) -> ToolResult:
        """Run a Python exploit script."""
        self.logger.info("Running Python exploit")

        script_path = None
        temp_file = None

        try:
            if is_path:
                script_path = script
            else:
                # Decode if base64
                if is_base64:
                    script_content = base64.b64decode(script).decode('utf-8')
                else:
                    script_content = script

                # Write to temp file
                temp_file = tempfile.NamedTemporaryFile(
                    mode='w',
                    suffix='.py',
                    dir=str(EXPLOIT_DIR),
                    delete=False,
                )
                temp_file.write(script_content)
                temp_file.close()
                script_path = temp_file.name

            # Build command
            cmd = [python_version, script_path]
            if args:
                cmd.extend(args)

            result = await self._run_process(cmd, timeout, env)

            return ToolResult(
                success=result["success"],
                data={
                    "returncode": result["returncode"],
                    "stdout": result["stdout"][:50000],
                    "stderr": result["stderr"][:10000],
                    "command": " ".join(cmd),
                    "timeout": result.get("timeout", False),
                },
                raw_output=result["stdout"][:10000] if result["success"] else result["stderr"][:5000],
                error=result["stderr"][:1000] if not result["success"] else None,
            )

        finally:
            if temp_file and os.path.exists(temp_file.name):
                os.unlink(temp_file.name)

    async def run_shell(
        self,
        script: str,
        args: Optional[List[str]] = None,
        shell: str = "bash",
        timeout: int = 120,
        env: Optional[Dict[str, str]] = None,
    ) -> ToolResult:
        """Run a shell script."""
        self.logger.info("Running shell exploit")

        temp_file = None

        try:
            # Write script to temp file
            temp_file = tempfile.NamedTemporaryFile(
                mode='w',
                suffix='.sh',
                dir=str(EXPLOIT_DIR),
                delete=False,
            )
            temp_file.write(script)
            temp_file.close()

            # Make executable
            os.chmod(temp_file.name, 0o755)

            # Build command
            cmd = [shell, temp_file.name]
            if args:
                cmd.extend(args)

            result = await self._run_process(cmd, timeout, env)

            return ToolResult(
                success=result["success"],
                data={
                    "returncode": result["returncode"],
                    "stdout": result["stdout"][:50000],
                    "stderr": result["stderr"][:10000],
                    "command": " ".join(cmd),
                },
                raw_output=result["stdout"][:10000] if result["success"] else result["stderr"][:5000],
                error=result["stderr"][:1000] if not result["success"] else None,
            )

        finally:
            if temp_file and os.path.exists(temp_file.name):
                os.unlink(temp_file.name)

    async def run_ruby(
        self,
        script: str,
        args: Optional[List[str]] = None,
        is_path: bool = False,
        timeout: int = 120,
    ) -> ToolResult:
        """Run a Ruby exploit script."""
        self.logger.info("Running Ruby exploit")

        script_path = None
        temp_file = None

        try:
            if is_path:
                script_path = script
            else:
                temp_file = tempfile.NamedTemporaryFile(
                    mode='w',
                    suffix='.rb',
                    dir=str(EXPLOIT_DIR),
                    delete=False,
                )
                temp_file.write(script)
                temp_file.close()
                script_path = temp_file.name

            cmd = ["ruby", script_path]
            if args:
                cmd.extend(args)

            result = await self._run_process(cmd, timeout)

            return ToolResult(
                success=result["success"],
                data={
                    "returncode": result["returncode"],
                    "stdout": result["stdout"][:50000],
                    "stderr": result["stderr"][:10000],
                    "command": " ".join(cmd),
                },
                raw_output=result["stdout"][:10000] if result["success"] else result["stderr"][:5000],
                error=result["stderr"][:1000] if not result["success"] else None,
            )

        finally:
            if temp_file and os.path.exists(temp_file.name):
                os.unlink(temp_file.name)

    async def prepare_exploit(
        self,
        content: str,
        filename: str,
        is_base64: bool = False,
        requirements: Optional[List[str]] = None,
    ) -> ToolResult:
        """Prepare an exploit for execution."""
        self.logger.info(f"Preparing exploit: {filename}")

        try:
            # Decode content
            if is_base64:
                file_content = base64.b64decode(content)
            else:
                file_content = content.encode('utf-8')

            # Save to exploit directory
            exploit_path = EXPLOIT_DIR / filename
            with open(exploit_path, 'wb') as f:
                f.write(file_content)

            # Make executable
            os.chmod(exploit_path, 0o755)

            # Install requirements if specified
            installed = []
            if requirements:
                for req in requirements:
                    result = await self._run_process(
                        ["pip3", "install", "--quiet", req],
                        timeout=60,
                    )
                    if result["success"]:
                        installed.append(req)

            return ToolResult(
                success=True,
                data={
                    "path": str(exploit_path),
                    "filename": filename,
                    "size_bytes": len(file_content),
                    "requirements_installed": installed,
                },
                raw_output=f"Prepared exploit at {exploit_path}",
            )

        except Exception as e:
            return ToolResult(
                success=False,
                data={},
                error=str(e),
            )

    async def list_exploits(self) -> ToolResult:
        """List prepared exploits."""
        exploits = []

        if EXPLOIT_DIR.exists():
            for f in EXPLOIT_DIR.iterdir():
                if f.is_file():
                    exploits.append({
                        "name": f.name,
                        "path": str(f),
                        "size_bytes": f.stat().st_size,
                        "modified": f.stat().st_mtime,
                    })

        return ToolResult(
            success=True,
            data={
                "exploits": exploits,
                "count": len(exploits),
                "directory": str(EXPLOIT_DIR),
            },
            raw_output=f"Found {len(exploits)} prepared exploits",
        )

    async def analyze_exploit(
        self,
        script: str,
        language: str = "auto",
    ) -> ToolResult:
        """Analyze exploit script for safety and requirements."""
        self.logger.info("Analyzing exploit script")

        # Detect language
        if language == "auto":
            if script.strip().startswith("#!/usr/bin/env python") or "import " in script:
                language = "python"
            elif script.strip().startswith("#!/usr/bin/env ruby") or "require " in script:
                language = "ruby"
            else:
                language = "shell"

        analysis = {
            "language": language,
            "lines": len(script.split('\n')),
            "imports": [],
            "dangerous_patterns": [],
            "network_operations": [],
            "file_operations": [],
            "command_execution": [],
        }

        # Python analysis
        if language == "python":
            # Find imports
            imports = re.findall(r'^(?:import|from)\s+(\w+)', script, re.MULTILINE)
            analysis["imports"] = list(set(imports))

            # Check for dangerous patterns
            dangerous = []
            if "eval(" in script:
                dangerous.append("eval() usage")
            if "exec(" in script:
                dangerous.append("exec() usage")
            if "subprocess" in script:
                dangerous.append("subprocess calls")
            if "os.system" in script:
                dangerous.append("os.system calls")
            if "__import__" in script:
                dangerous.append("dynamic imports")
            analysis["dangerous_patterns"] = dangerous

            # Network operations
            if any(x in script for x in ["socket", "requests", "urllib", "http.client"]):
                analysis["network_operations"].append("network library usage")
            if "connect(" in script:
                analysis["network_operations"].append("socket connections")

            # File operations
            if "open(" in script:
                analysis["file_operations"].append("file I/O")
            if any(x in script for x in ["os.remove", "shutil", "os.unlink"]):
                analysis["file_operations"].append("file deletion")

        # Shell analysis
        elif language == "shell":
            if "curl " in script or "wget " in script:
                analysis["network_operations"].append("HTTP requests")
            if "nc " in script or "netcat" in script:
                analysis["network_operations"].append("netcat usage")
            if "rm -rf" in script:
                analysis["dangerous_patterns"].append("recursive file deletion")
            if "> /dev/" in script:
                analysis["dangerous_patterns"].append("device file writes")

        # Estimate requirements
        if language == "python":
            common_deps = {
                "requests": "requests",
                "pwntools": "pwntools",
                "paramiko": "paramiko",
                "impacket": "impacket",
                "scapy": "scapy",
                "cryptography": "cryptography",
                "pycryptodome": "pycryptodome",
            }
            requirements = []
            for imp, pkg in common_deps.items():
                if imp in analysis["imports"]:
                    requirements.append(pkg)
            analysis["likely_requirements"] = requirements

        return ToolResult(
            success=True,
            data=analysis,
            raw_output=f"Analyzed {language} script ({analysis['lines']} lines)",
        )


if __name__ == "__main__":
    ExploitRunnerServer.main()
