#!/usr/bin/env python3
"""
OpenSploit MCP Server: cve-lookup

CVE lookup and vulnerability research using NVD API and local databases.
"""

import asyncio
import json
import os
import re
import ssl
import urllib.request
import urllib.error
from datetime import datetime
from typing import Any, Dict, List, Optional

from mcp_common import BaseMCPServer, ToolResult


# NVD API endpoints
NVD_CVE_API = "https://services.nvd.nist.gov/rest/json/cves/2.0"
NVD_CPE_API = "https://services.nvd.nist.gov/rest/json/cpes/2.0"

# Common products and their CPE names (for quick matching)
COMMON_CPES = {
    "apache": "cpe:2.3:a:apache:http_server",
    "nginx": "cpe:2.3:a:f5:nginx",
    "mysql": "cpe:2.3:a:oracle:mysql",
    "postgresql": "cpe:2.3:a:postgresql:postgresql",
    "openssh": "cpe:2.3:a:openbsd:openssh",
    "php": "cpe:2.3:a:php:php",
    "wordpress": "cpe:2.3:a:wordpress:wordpress",
    "drupal": "cpe:2.3:a:drupal:drupal",
    "joomla": "cpe:2.3:a:joomla:joomla",
    "jenkins": "cpe:2.3:a:jenkins:jenkins",
    "tomcat": "cpe:2.3:a:apache:tomcat",
    "struts": "cpe:2.3:a:apache:struts",
    "redis": "cpe:2.3:a:redis:redis",
    "mongodb": "cpe:2.3:a:mongodb:mongodb",
    "elasticsearch": "cpe:2.3:a:elastic:elasticsearch",
    "docker": "cpe:2.3:a:docker:docker",
    "kubernetes": "cpe:2.3:a:kubernetes:kubernetes",
    "linux": "cpe:2.3:o:linux:linux_kernel",
    "windows": "cpe:2.3:o:microsoft:windows",
    "sudo": "cpe:2.3:a:sudo_project:sudo",
    "netdata": "cpe:2.3:a:netdata:netdata",
    "xwiki": "cpe:2.3:a:xwiki:xwiki",
    "gitlab": "cpe:2.3:a:gitlab:gitlab",
}


class CVELookupServer(BaseMCPServer):
    """MCP server for CVE lookup and vulnerability research."""

    def __init__(self):
        super().__init__(
            name="cve-lookup",
            description="CVE lookup and vulnerability research",
            version="1.0.0",
        )

        # NVD API key (optional, for higher rate limits)
        self.nvd_api_key = os.environ.get("NVD_API_KEY")

        self.register_method(
            name="lookup",
            description="Look up a specific CVE by ID",
            params={
                "cve_id": {
                    "type": "string",
                    "required": True,
                    "description": "CVE ID (e.g., CVE-2024-32019)",
                },
            },
            handler=self.lookup_cve,
        )

        self.register_method(
            name="search",
            description="Search CVEs by product/keyword",
            params={
                "keyword": {
                    "type": "string",
                    "required": True,
                    "description": "Search keyword (product name, e.g., 'apache' or 'netdata')",
                },
                "version": {
                    "type": "string",
                    "description": "Product version to filter (e.g., '1.45.2')",
                },
                "severity": {
                    "type": "enum",
                    "values": ["LOW", "MEDIUM", "HIGH", "CRITICAL"],
                    "description": "Filter by CVSS severity",
                },
                "limit": {
                    "type": "integer",
                    "default": 20,
                    "description": "Maximum results to return",
                },
                "year": {
                    "type": "integer",
                    "description": "Filter by year (e.g., 2024)",
                },
            },
            handler=self.search_cves,
        )

        self.register_method(
            name="recent",
            description="Get recent CVEs (last 7 days)",
            params={
                "severity": {
                    "type": "enum",
                    "values": ["LOW", "MEDIUM", "HIGH", "CRITICAL"],
                    "description": "Filter by severity",
                },
                "limit": {
                    "type": "integer",
                    "default": 20,
                    "description": "Maximum results",
                },
            },
            handler=self.recent_cves,
        )

        self.register_method(
            name="exploits",
            description="Find known exploits for a CVE",
            params={
                "cve_id": {
                    "type": "string",
                    "required": True,
                    "description": "CVE ID to search exploits for",
                },
            },
            handler=self.find_exploits,
        )

    def _make_nvd_request(
        self, endpoint: str, params: Dict[str, str], timeout: int = 30
    ) -> Optional[Dict]:
        """Make a request to NVD API."""
        # Build URL with params
        query_params = "&".join([f"{k}={v}" for k, v in params.items()])
        url = f"{endpoint}?{query_params}" if query_params else endpoint

        headers = {
            "User-Agent": "OpenSploit-CVE-Lookup/1.0",
        }
        if self.nvd_api_key:
            headers["apiKey"] = self.nvd_api_key

        ctx = ssl.create_default_context()
        request = urllib.request.Request(url, headers=headers)

        try:
            response = urllib.request.urlopen(request, timeout=timeout, context=ctx)
            return json.loads(response.read().decode("utf-8"))
        except urllib.error.HTTPError as e:
            self.logger.error(f"NVD API error: {e.code} - {e.reason}")
            return None
        except Exception as e:
            self.logger.error(f"Request failed: {e}")
            return None

    def _parse_cve(self, cve_item: Dict) -> Dict:
        """Parse NVD CVE item into simplified format."""
        cve = cve_item.get("cve", {})
        cve_id = cve.get("id", "Unknown")

        # Get description
        descriptions = cve.get("descriptions", [])
        description = next(
            (d["value"] for d in descriptions if d.get("lang") == "en"),
            descriptions[0]["value"] if descriptions else "No description",
        )

        # Get CVSS score (prefer v3.1, then v3.0, then v2)
        metrics = cve.get("metrics", {})
        cvss_score = None
        cvss_severity = None
        cvss_vector = None

        if "cvssMetricV31" in metrics:
            cvss_data = metrics["cvssMetricV31"][0]["cvssData"]
            cvss_score = cvss_data.get("baseScore")
            cvss_severity = cvss_data.get("baseSeverity")
            cvss_vector = cvss_data.get("vectorString")
        elif "cvssMetricV30" in metrics:
            cvss_data = metrics["cvssMetricV30"][0]["cvssData"]
            cvss_score = cvss_data.get("baseScore")
            cvss_severity = cvss_data.get("baseSeverity")
            cvss_vector = cvss_data.get("vectorString")
        elif "cvssMetricV2" in metrics:
            cvss_data = metrics["cvssMetricV2"][0]["cvssData"]
            cvss_score = cvss_data.get("baseScore")
            cvss_severity = metrics["cvssMetricV2"][0].get("baseSeverity", "UNKNOWN")
            cvss_vector = cvss_data.get("vectorString")

        # Get references
        references = []
        for ref in cve.get("references", [])[:10]:  # Limit to 10
            references.append({
                "url": ref.get("url"),
                "source": ref.get("source"),
                "tags": ref.get("tags", []),
            })

        # Get affected products (CPE)
        affected = []
        for config in cve.get("configurations", []):
            for node in config.get("nodes", []):
                for cpe in node.get("cpeMatch", []):
                    if cpe.get("vulnerable"):
                        criteria = cpe.get("criteria", "")
                        # Parse CPE to get product info
                        parts = criteria.split(":")
                        if len(parts) >= 5:
                            affected.append({
                                "vendor": parts[3] if len(parts) > 3 else "unknown",
                                "product": parts[4] if len(parts) > 4 else "unknown",
                                "version_start": cpe.get("versionStartIncluding"),
                                "version_end": cpe.get("versionEndExcluding") or cpe.get("versionEndIncluding"),
                            })

        # Get weaknesses (CWE)
        weaknesses = []
        for weakness in cve.get("weaknesses", []):
            for desc in weakness.get("description", []):
                if desc.get("lang") == "en":
                    weaknesses.append(desc.get("value"))

        return {
            "cve_id": cve_id,
            "description": description,
            "cvss_score": cvss_score,
            "cvss_severity": cvss_severity,
            "cvss_vector": cvss_vector,
            "published": cve.get("published"),
            "last_modified": cve.get("lastModified"),
            "affected_products": affected[:10],  # Limit
            "weaknesses": weaknesses,
            "references": references,
        }

    async def lookup_cve(self, cve_id: str) -> ToolResult:
        """Look up a specific CVE by ID."""
        # Normalize CVE ID
        cve_id = cve_id.upper()
        if not cve_id.startswith("CVE-"):
            cve_id = f"CVE-{cve_id}"

        self.logger.info(f"Looking up {cve_id}")

        response = self._make_nvd_request(NVD_CVE_API, {"cveId": cve_id})

        if not response:
            return ToolResult(
                success=False,
                data={},
                error="Failed to query NVD API",
            )

        vulnerabilities = response.get("vulnerabilities", [])
        if not vulnerabilities:
            return ToolResult(
                success=False,
                data={},
                error=f"CVE {cve_id} not found",
            )

        cve_data = self._parse_cve(vulnerabilities[0])

        severity_emoji = {
            "CRITICAL": "[CRIT]",
            "HIGH": "[HIGH]",
            "MEDIUM": "[MED]",
            "LOW": "[LOW]",
        }
        sev = severity_emoji.get(cve_data.get("cvss_severity", ""), "")

        return ToolResult(
            success=True,
            data=cve_data,
            raw_output=f"{cve_id} {sev} CVSS:{cve_data.get('cvss_score', 'N/A')} - {cve_data['description'][:200]}...",
        )

    async def search_cves(
        self,
        keyword: str,
        version: str = None,
        severity: str = None,
        limit: int = 20,
        year: int = None,
    ) -> ToolResult:
        """Search CVEs by product/keyword."""
        self.logger.info(f"Searching CVEs: keyword={keyword}, version={version}")

        params = {"keywordSearch": keyword, "resultsPerPage": str(min(limit, 100))}

        # Add severity filter
        if severity:
            # NVD uses cvssV3Severity
            params["cvssV3Severity"] = severity.upper()

        # Add year filter
        if year:
            params["pubStartDate"] = f"{year}-01-01T00:00:00.000"
            params["pubEndDate"] = f"{year}-12-31T23:59:59.999"

        response = self._make_nvd_request(NVD_CVE_API, params, timeout=60)

        if not response:
            return ToolResult(
                success=False,
                data={},
                error="Failed to query NVD API",
            )

        vulnerabilities = response.get("vulnerabilities", [])
        results = []

        for vuln in vulnerabilities:
            cve_data = self._parse_cve(vuln)

            # Filter by version if specified
            if version:
                version_match = False
                for affected in cve_data.get("affected_products", []):
                    v_start = affected.get("version_start")
                    v_end = affected.get("version_end")
                    # Simple version comparison (could be improved)
                    if v_start and v_end:
                        if v_start <= version <= v_end:
                            version_match = True
                            break
                    elif not v_start and not v_end:
                        version_match = True  # Assume all versions affected
                        break
                if not version_match:
                    continue

            results.append({
                "cve_id": cve_data["cve_id"],
                "cvss_score": cve_data.get("cvss_score"),
                "cvss_severity": cve_data.get("cvss_severity"),
                "description": cve_data["description"][:300],
                "published": cve_data.get("published"),
            })

            if len(results) >= limit:
                break

        return ToolResult(
            success=True,
            data={
                "query": keyword,
                "version": version,
                "total_results": response.get("totalResults", 0),
                "returned": len(results),
                "cves": results,
            },
            raw_output=f"Found {len(results)} CVEs for '{keyword}'",
        )

    async def recent_cves(
        self, severity: str = None, limit: int = 20
    ) -> ToolResult:
        """Get recent CVEs from last 7 days."""
        from datetime import timedelta

        now = datetime.utcnow()
        week_ago = now - timedelta(days=7)

        params = {
            "pubStartDate": week_ago.strftime("%Y-%m-%dT00:00:00.000"),
            "pubEndDate": now.strftime("%Y-%m-%dT23:59:59.999"),
            "resultsPerPage": str(min(limit, 100)),
        }

        if severity:
            params["cvssV3Severity"] = severity.upper()

        response = self._make_nvd_request(NVD_CVE_API, params, timeout=60)

        if not response:
            return ToolResult(
                success=False,
                data={},
                error="Failed to query NVD API",
            )

        vulnerabilities = response.get("vulnerabilities", [])
        results = []

        for vuln in vulnerabilities[:limit]:
            cve_data = self._parse_cve(vuln)
            results.append({
                "cve_id": cve_data["cve_id"],
                "cvss_score": cve_data.get("cvss_score"),
                "cvss_severity": cve_data.get("cvss_severity"),
                "description": cve_data["description"][:300],
                "published": cve_data.get("published"),
            })

        return ToolResult(
            success=True,
            data={
                "period": "last 7 days",
                "severity_filter": severity,
                "total_results": response.get("totalResults", 0),
                "returned": len(results),
                "cves": results,
            },
            raw_output=f"Found {len(results)} recent CVEs",
        )

    async def find_exploits(self, cve_id: str) -> ToolResult:
        """Find known exploits for a CVE."""
        # Normalize CVE ID
        cve_id = cve_id.upper()
        if not cve_id.startswith("CVE-"):
            cve_id = f"CVE-{cve_id}"

        self.logger.info(f"Finding exploits for {cve_id}")

        # First, get the CVE details for references
        response = self._make_nvd_request(NVD_CVE_API, {"cveId": cve_id})

        if not response or not response.get("vulnerabilities"):
            return ToolResult(
                success=False,
                data={},
                error=f"CVE {cve_id} not found",
            )

        cve_data = self._parse_cve(response["vulnerabilities"][0])

        # Look for exploit references
        exploit_sources = []
        exploit_refs = []

        for ref in cve_data.get("references", []):
            url = ref.get("url", "").lower()
            tags = ref.get("tags", [])

            # Check for exploit-related tags or URLs
            is_exploit = (
                "Exploit" in tags
                or "exploit-db.com" in url
                or "github.com" in url and ("exploit" in url or "poc" in url or "CVE" in url.upper())
                or "packetstorm" in url
                or "0day" in url
                or "rapid7.com" in url
            )

            if is_exploit:
                exploit_refs.append({
                    "url": ref.get("url"),
                    "source": ref.get("source"),
                    "tags": tags,
                })

            # Track potential sources
            if "exploit-db.com" in url:
                exploit_sources.append("ExploitDB")
            if "github.com" in url:
                exploit_sources.append("GitHub")
            if "rapid7.com" in url or "metasploit" in url.lower():
                exploit_sources.append("Metasploit")
            if "packetstorm" in url:
                exploit_sources.append("PacketStorm")

        # Extract CVE year and number for searchsploit-style lookup
        cve_match = re.match(r"CVE-(\d{4})-(\d+)", cve_id)
        searchsploit_query = f"{cve_match.group(1)}-{cve_match.group(2)}" if cve_match else cve_id

        return ToolResult(
            success=True,
            data={
                "cve_id": cve_id,
                "cvss_score": cve_data.get("cvss_score"),
                "cvss_severity": cve_data.get("cvss_severity"),
                "exploit_references": exploit_refs,
                "exploit_sources": list(set(exploit_sources)),
                "searchsploit_query": searchsploit_query,
                "metasploit_search": f"search cve:{cve_id}",
            },
            raw_output=f"Found {len(exploit_refs)} exploit references for {cve_id}",
        )


if __name__ == "__main__":
    CVELookupServer.main()
